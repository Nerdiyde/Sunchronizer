#                                  _   _                 _  _               _
#                                 | \ | |               | |(_)             | |
#  __      ____      ____      __ |  \| |  ___  _ __  __| | _  _   _     __| |  ___
#  \ \ /\ / /\ \ /\ / /\ \ /\ / / | . ` | / _ \| '__|/ _` || || | | |   / _` | / _ \
#   \ V  V /  \ V  V /  \ V  V /_ | |\  ||  __/| |  | (_| || || |_| | _| (_| ||  __/
#    \_/\_/    \_/\_/    \_/\_/(_)|_| \_| \___||_|   \__,_||_| \__, |(_)\__,_| \___|
#                                                               __/ |
#                                                              |___/
#     Infos on https://www.Nerdiy.de/
#
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version. 
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <http://www.gnu.org/licenses/>.#
#     You can find additional infos about the licensing here: https://nerdiy.de/en/lizenz/
#

# === Infos ===

# This firmware is written for the Sunchronizer series by Nerdiy.de

# Links:
# STL files for 3D printing:
#   Version S1: https://nerdiy.de/en/product-2/sunchronizer-s1-400w-solartracker-fuer-elevation-achse-3d-druckbar-stl-dateien/
#   Version D1: https://nerdiy.de/en/product-2/sunchronizer-d1-dual-axis-solartracker-fuer-azimut-und-elevation-achse-3d-druckbar-stl-dateien/
#   Version S2:
#   Version D2:
# GitHub: https://github.com/Nerdiyde/Sunchronizer
# Project Log: https://hackaday.io/project/195626-sunchronizer-singledual-axis-solar-tracker

# It's designed for the following hardware:
# - MCU: ESP32-S3
# - IMU: BNO085 for measurement of panel elevation angle and heading/azimuth angle
# - RTC: DS3231 for tracking system time
# - GNSS: BN-220 GNSS receiver for tracking position and system time
# - H-Bridge: TA6568
# - Current sensor: 2x INA219 for measuring motor current and voltage
# - Power supply: The system is powered by a 12V/3A input. I highly recommend powering via USB-C breakout board and USB-C Power Delivery power supply. On the PCB is a 5V Step-Down converter to provide 5V for the MCU and peripherals.

# Movement priority:
# The rotation and lifting motors must not run in parallel to not increase the overall supply current to >3A (which is the limit of the power supply).
# Lifting and lowering has a higher priority than any rotational movements. So if both is planned, the lowering/lifting is finished first.

# Safety features:
# All weather data retrieval is currently based on an active API connection to openweathermaps.org.
# You need to sign up and create an API key.
# Go to sleep mode in case of:
#  - wind gusts are too high
#  - wind speed are too high
#  - OWM data is expired or not available
# Go to cloudy mode in case of:
#  (When cloudy mode is active the panel is lowered to a position parallel to the ground)
#  - Cloud coverage reaches cloudy threshold 

# Stand by position:
# This position describes the position where the panel is lowered to the (by hardware) minimum possible elevation angle.
# and the azimuth angle that is as close as possible to 180° ("South").
# Bot values are changeable in the config with the parameters "stand_by_mode_azimuth_target_angle" and "stand_by_mode_elevation_target_angle".

# Cloudy mode position:
# When cloudy mode is activated, the panel elevation angle is lowered as close to 0° as possible.
# In overcast conditions, the diffuse horizontal irradiance (DHI) often exceeds the direct normal irradiance (DNI).
# Lowering the panel in this scenario increases its exposure to diffuse light from the entire sky, 
# thereby maximizing energy yield when DHI > DNI.

# Manual control:
# Any manual interaction (pyhsical/software button press) deactivates all automations.
# The automations need to be acitvated manually after manual interaction is finished.


substitutions:

  # Project related definitions
  firmware_version: "2026.1.0"                  # Semantic versioning format (YYYY.MM.patch) - Example: 2025.11.0
  project_name: "Nerdiy.Sunchronizer"           # Unique project identifier used for HomeAssistant integration
  fiendly_name: "Sunchronizer_CTRLR_V1.3"       # Human-readable device name displayed in UI - Example: Sunchronizer_CTRLR_V1.3
  name: "sunchronizer-ctrlr-v1-3"               # Hostname for mDNS discovery and MQTT - Example: sunchronizer-ctrlr-v1-3
  add_mac_to_name: False                        # When true, appends MAC address to device name to avoid naming conflicts
  minimum_esphome_version: "2026.1.0"           # Minimum required ESPHome version for this firmware - Example: 2025.11.0
  cpu_frequency: "240MHz"                       # ESP32 CPU clock frequency - Supported: 80MHz, 160MHz, 240MHz
  made_for_pcb_version: 1.3                     # Firmware-PCB version compatibility - Example: 1.3

  # security relevant definitions
  # See https://esphome.io/guides/security_best_practices/ for additional information
  #ota_password: !secret ota_password            # uncomment to activate password protection for OTA
  #api_key: !secret api_key                      # uncomment to activate API access
  http_request_ssl_verification: "false"

  gpio:
    # GNSS communication GPIOs
    gnss_rx: "GPIO3"                  # UART RX pin for BN-220 GNSS receiver
    gnss_tx: "GPIO4"                  # UART TX pin for BN-220 GNSS receiver
    
    # BNO085 IMU communication GPIOs
    bno085_rx: "GPIO7"                # UART RX pin for BNO085 9-DOF IMU
    bno085_tx: "GPIO8"                # UART TX pin for BNO085 9-DOF IMU

    # I2C GPIOs
    sda: "GPIO5"                      # I2C data line for INA219, DS3231, SSD1306, MCP23017
    scl: "GPIO6"                      # I2C clock line for INA219, DS3231, SSD1306, MCP23017

    # Status LEDs GPIO
    mcu_led_out: "GPIO21"             # On-board LED for firmware status indication
    led_out: "GPIO9"                  # External RGB LED strip WS2812 data pin (RMT output)

  gpio_ids:
    # Motor controller GPIOs
    motor_elevation_plus: 8           # MCP23017 GPIO pin for elevation motor forward direction
    motor_elevation_minus: 9          # MCP23017 GPIO pin for elevation motor reverse direction
    motor_azimuth_plus: 11            # MCP23017 GPIO pin for azimuth motor forward direction (CW)
    motor_azimuth_minus: 10           # MCP23017 GPIO pin for azimuth motor reverse direction (CCW)

    # Button GPIOs
    button_up_cw_physical: 1          # MCP23017 GPIO pin for physical up/CW button
    button_down_ccw_physical: 0       # MCP23017 GPIO pin for physical down/CCW button

    # Endstop GPIOs
    azimuth_endstop_max_cw_pos: 6    # MCP23017 GPIO pin for azimuth CW endstop sensor
    azimuth_endstop_max_ccw_pos: 7   # MCP23017 GPIO pin for azimuth CCW endstop sensor

  # I2C addresses
  i2c_address:
    ina219_elevation_motor: "0x40"    # I2C address for elevation motor current/voltage sensor
    ina219_azimuth_motor: "0x41"      # I2C address for azimuth motor current/voltage sensor
    ds3231: "0x68"                    # I2C address for DS3231 real-time clock module
    ssd1306: "0x3C"                   # I2C address for SSD1306 OLED display (128x64)
    mcp23017: "0x20"                  # I2C address for MCP23017 GPIO expander (16 I/O pins)

  # URL values
  url:
    initial_connection_test_url: "http://google.com"      # URL for initial internet connectivity test - Example: "http://google.com"
    ntp_server1: "0.pool.ntp.org"                         # Primary NTP server for time synchronization
    ntp_server2: "1.pool.ntp.org"                         # Secondary NTP server for time synchronization
    ntp_server3: "2.pool.ntp.org"                         # Tertiary NTP server for time synchronization

  webserver:
    port: 80                          # HTTP port for web interface - Example: 80
    user: "admin"                     # Default username for webserver authentication (CAUTION: Uncomment implementation in code to activate)
    password: "please_change_me"      # Default password for webserver authentication (CAUTION: Change this immediately!)

  # intervals, delays and time settings
  owm_data_retrieval_check_period: "60s"        # Check interval to see if OWM data needs refreshing - Example: "60s"
  status_text_sensor_update_interval: "60s"     # Update interval for status text sensors - Example: "60s"
  status_led_update_interval: "1s"              # Update interval for status LED colors - Example: "1s"
  internet_connection_test_interval: "300s"     # How often to test internet connectivity - Example: "300s" (5 minutes)
  owm_data_expiration_time: "360"               # OWM data max age in seconds before considered old - Example: "360" (6 minutes)
  owm_data_expiration_shutdown_time: "720"      # OWM data max age in seconds before safety shutdown (stand by mode) - Example: "720" (12 minutes)
  panel_movement_plausible_check_delay: "2000"  # Delay in ms before checking if panel movement is plausible - Example: "2000" (2 seconds)
  azimuth_motor_direction_change_threshold: "1.0"  # Minimum heading change in degrees to detect azimuth motor direction - Example: "1.0" (1 degree)
  elevation_motor_direction_detection_tolerance: "2.0"  # Tolerance in degrees for elevation motor direction detection (accounts for sensor accuracy) - Example: "1.0" (±1°)
  azimuth_motor_direction_detection_tolerance: "2.0"  # Tolerance in degrees for azimuth motor direction detection (accounts for compass drift) - Example: "2.0" (±2°)
  elevation_target_angle_timeout: "120"         # Maximum time in seconds to reach elevation target angle before timeout error - Example: "300" (5 minutes)
  azimuth_target_angle_timeout: "230"           # Maximum time in seconds to reach azimuth target angle before timeout error - Example: "300" (5 minutes)
  mcu_led_blink_interval: "1s"                  # Blink interval for MCU LED - Example: "1s"

  # Standard & initial values
  bno085_baud_rate: "115200"                    # Baud rate for BNO085 IMU communication - 115200 for RVC mode, 3000000 for SHTP mode
  gnss_baud_rate: "9600"                        # Baud rate for BN-220 GNSS receiver communication - Example: "9600"

  coordinates:
    standard_latitude: "51.4818445"               # Initial device latitude (WGS84) - Can be changed via web frontend - Example: "51.4818445"
    standard_longitude: "7.2162363"               # Initial device longitude (WGS84) - Can be changed via web frontend - Example: "7.2162363"

  # Weather threshold hysteresis values - Separate activation and deactivation thresholds to prevent oscillation
  # Hysteresis prevents rapid switching when weather values hover near thresholds. Lower deactivation threshold ensures stability.
  weather_hysteresis:
    cloudy_mode_activation_threshold: "90"         # Cloud coverage percentage to activate cloudy mode - Activation point (higher value) - Example: "90" (90%)
    cloudy_mode_deactivation_threshold: "70"       # Cloud coverage percentage to deactivate cloudy mode - Deactivation point (lower value prevents oscillation) - Example: "70" (70%)
    wind_speed_activation_threshold: "40"          # Wind speed in m/s to activate stand by mode for protection - Activation point (higher value) - Example: "40" m/s
    wind_speed_deactivation_threshold: "30"        # Wind speed in m/s to deactivate stand by mode - Deactivation point (lower value, typically 70-75% of activation) - Example: "30" m/s
    wind_gusts_activation_threshold: "55"          # Wind gust peak in m/s to activate stand by mode for protection - Activation point (higher value) - Example: "55" m/s
    wind_gusts_deactivation_threshold: "40"        # Wind gust peak in m/s to deactivate stand by mode - Deactivation point (lower value, typically 70-75% of activation) - Example: "40" m/s

  initial_value:
    cloudy_mode_activation_threshold: "90"         # Default cloud coverage percentage to activate cloudy mode - Example: "90" (90%)
    wind_speed_protection_activation_threshold: "40"   # Default wind speed threshold in m/s to activate stand by mode - Example: "40"
    wind_gusts_protection_activation_threshold: "55"   # Default wind gust threshold in m/s to activate stand by mode - Example: "55"
    stand_by_mode_azimuth_target_angle: "180"     # Default azimuth target angle (South) for stand by mode in degrees - Example: "180"
    magnetic_declination: "0.0"                    # Initial magnetic declination correction in degrees (will be calibrated) - Example: "0.0"
    stand_by_mode_elevation_target_angle: "-90"   # Default elevation target angle for stand by mode in degrees - Example: "-90"
    panel_azimuth_angle_max: "350"                # Maximum allowed azimuth angle when properly aligned - Example: "350"
    panel_azimuth_angle_min: "10"                 # Minimum allowed azimuth angle when properly aligned - Example: "10"
    panel_elev_target_angle_tolerance: "2"        # Acceptable elevation angle deviation from target in degrees - Example: "2"
    panel_azimuth_target_angle_tolerance: "2"     # Acceptable azimuth angle deviation from target in degrees - Example: "2"
    panel_azimuth_orientation: "180"              # Initial panel azimuth orientation (compass heading) in degrees - Example: "180" (South)
    number: "123.456"                             # Test/placeholder number value - Used for testing sensor formatting
    panel_elev_angle_max: "90.0"                  # Maximum elevation angle in degrees (0=horizontal, 90=vertical) - Example: "90.0"
    panel_elev_angle_min: "-90.0"                 # Minimum elevation angle in degrees - Example: "-90.0"
    status_text_normal: "Normal"                  # Default status text when system is operating normally - Example: "Normal"
    initial_owm_key_value: "abcdefghijkl"         # Placeholder OWM API key - Must be replaced with valid key for weather data
    ccw_endstop_azimuth_pointing_direction: "77.0"   # Azimuth angle when base is pointing South and CCW endstop is reached - Example: "77.0"
    stand_by_mode_elevation_trigger_angle: 5      # Sun elevation angle threshold in degrees for stand by mode activation - Example: 5
    elevation_motor_blocked_current_threshold: "3.0"   # Motor blocked detection threshold in A - Example: "3.0" (3A)
    azimuth_motor_blocked_current_threshold: "2.5"     # Motor blocked detection threshold in A - Example: "2.5" (2.5A)
    led_internal_brightness_day: 70.0             # Internal LED brightness (0-100%) during daytime - Example: 70.0
    led_external_brightness_day: 50.0             # External RGB LED brightness (0-100%) during daytime - Example: 50.0
    led_internal_brightness_night: 50.0           # Internal LED brightness (0-100%) during nighttime - Example: 50.0
    led_external_brightness_night: 20.0           # External RGB LED brightness (0-100%) during nighttime - Example: 20.0

  # Other values
  timezone: "Europe/Berlin"                      # Device timezone for time and scheduling - See: https://esphome.io/components/time/index.html
  cloudy_mode_elevation_target_angle: "0.0"      # Target elevation angle (horizontal) when cloudy mode is active - Example: "0.0"
  api_reboot_timeout: "15min"                    # Timeout before automatic reboot if HomeAssistant connection is lost - Set "0s" to disable
  show_cover_component: "false"                  # Whether to show cover component interface (legacy) - Example: "false"
  compass_to_panel_heading_inversion_degree: 180.0   # IMU heading inversion offset to align with panel orientation - Example: 180.0
  total_psram_in_bytes: 8388608.0                # Total PSRAM capacity on ESP32-S3 - 8 MB for this module
  total_heap_in_bytes: 327680.0                  # Total heap memory available on ESP32-S3 - Approximately 320 KB
  
  azimuth_motor_blocked_current_max: 3.0         # Maximum configurable blocked current threshold in A - Example: 3.0
  azimuth_motor_blocked_current_min: 0.1          # Minimum configurable blocked current threshold in A - Example: 0.1
  elevation_motor_blocked_current_max: 3.0      # Maximum configurable blocked current threshold in A - Example: 3.0
  elevation_motor_blocked_current_min: 0.1       # Minimum configurable blocked current threshold in A - Example: 0.1

  # Magnetic calibration periodic check settings
  magnetic_calibration_periodic_check_enabled: "true"    # Enable/disable periodic magnetic calibration check - Example: "true"
  magnetic_calibration_periodic_check_interval_minutes: 60   # Interval in minutes for periodic magnetic calibration check - Example: 60 (1 hour)
  magnetic_calibration_periodic_check_interval_seconds: 3600   # Interval in seconds for periodic magnetic calibration check - auto-calculated: 60 * 60 = 3600

  # LED colors (used for the status leds)
  led_color_red: [1.0, 0.0, 0.0]                # RGB color for error/fault status indication - Red
  led_color_yellow: [1.0, 1.0, 0.0]             # RGB color for warning/caution status indication - Yellow
  led_color_green: [0.0, 1.0, 0.0]              # RGB color for normal/okay status indication - Green
  led_color_blue: [0.0, 0.0, 1.0]               # RGB color for calibration/measurement status indication - Blue

  # timeouts
  elevation_measurement_lifting_max_wait_time: "80"        # Maximum duration for elevation lifting measurement in seconds - Example: "80" (300mm actuator takes ~70s)
  elevation_measurement_lowering_max_wait_time: "70"       # Maximum duration for elevation lowering measurement in seconds - Example: "70" (300mm actuator takes ~60s)
  azimuth_measurement_max_wait_time: "300"                 # Maximum duration for azimuth measurement in seconds - Example: "300" (JGY-370 5rpm takes ~260s)
  magnetic_declination_calibration_max_wait_time: "300"    # Maximum duration for magnetic declination calibration in seconds - Example: "300"
  inital_angle_state_initialization_max_wait_time: "30"    # Maximum duration for initial angle state initialization in seconds - Example: "30"
  azimuth_endstop_distance_target: "225.0"                 # Expected distance in degrees between CCW and CW endstops - Example: "225.0" (360° - 135° safe range)
  azimuth_endstop_distance_tolerance_percent: "10.0"        # Tolerance in percent for endstop distance validation - Example: "5.0" (±5% = ±11.25°)

  # gnss signal quality criteria
  gnss_min_required_gnss_hdop: "2"               # Maximum HDOP value for valid GNSS position (lower is better) - Example: "2"
  gnss_min_required_sat_count: "4"               # Minimum number of satellites for valid GNSS position - Example: "4"

  # motor settings
  motor_elevation_max_current_at_idle: "0.02"            # Current threshold in A to classify motor as idle - Example: 0.02 (20mA)
  motor_elevation_min_current_active: "0.01"             # Minimum current in A to classify motor as active - Example: 0.01 (10mA)
  motor_elevation_nominal_supply_voltage: "12"           # Nominal motor supply voltage in V - Example: "12"
  motor_elevation_supply_voltage_tolerance: "3"          # Maximum allowed voltage deviation in V (±) - Example: "3"

  motor_azimuth_max_current_at_idle: "0.02"              # Current threshold in A to classify motor as idle - Example: 0.02 (20mA)
  motor_azimuth_min_current_active: "0.01"               # Minimum current in A to classify motor as active - Example: 0.01 (10mA)
  motor_azimuth_nominal_supply_voltage: "12"             # Nominal motor supply voltage in V - Example: "12"
  motor_azimuth_supply_voltage_tolerance: "3"            # Maximum allowed voltage deviation in V (±) - Example: "3"
  
  motor_connection_error_check_delay: "5000"    # Delay in ms before motor connection error check to allow current to rise - Example: "2000" (2s)
  motor_high_current_check_delay: "5000"        # Delay in ms before motor blocked check to allow current rise and overcome initial movement - Example: "5000" (5s)


  # panel movement fault detection
  panel_block_detection_elevation_opening_angle_change_minimum: "-1.5" # Minimum angle change in degrees for elevation opening (negative value, smaller = less sensitive) - Example: "-1.5"
  panel_block_detection_elevation_closing_angle_change_minimum: "0.5"  # Minimum angle change in degrees for elevation closing (smaller = less sensitive) - Example: "0.5"

  panel_block_detection_azimuth_cw_angle_change_minimum: "-1.5" # Minimum angle change in degrees for clockwise azimuth movement (negative value, smaller = less sensitive) - Example: "-1.5"
  panel_block_detection_azimuth_ccw_angle_change_minimum: "1.5"  # Minimum angle change in degrees for counter-clockwise azimuth movement (smaller = less sensitive) - Example: "1.5"

  # Stand by mode settings
  stand_by_mode_elevtation_trigger_angle_tolerance: "2"      # Tolerance in degrees for elevation angle to consider panel in standby/park position - Example: "2"

  # display settings
  screensaver_offset: "0"                        # Screensaver position offset in pixels from edges - Example: "0" (no offset)

  # Status text messages - Error and status messages displayed on the web frontend
  status_text_messages:
    owm_api_key_not_entered: "OWM API Key is not entered. Auto OWM data retrieval deactivated. Enter a valid OWM API key to use this feature."
    owm_api_key_not_valid: "OWM API Key is not valid. Auto OWM data retrieval deactivated. Enter a valid OWM API key to use this feature."
    internet_test_url_not_reachable: "Test URL not reachable. Internet connection might not be available."
    elevation_motor_sensor_not_ready: "Elevation Motor current sensor not ready. Check correct I2C address and solder jumper settings."
    motor_voltage_not_valid: "Error: Motor voltage is not valid."
    axis_mode_elevation_only: "\"Axis control mode\" is set to \"Elevation Axis only\". Azimuth axis is deactivated."
    azimuth_motor_sensor_not_ready: "Azimuth Motor current sensor not ready. Check correct I2C address and solder jumper settings."
    elevation_measurement_active: "Elevation angle boundaries measurement active..."
    elevation_measurement_fault: "Elevation angle measurement. Check the motor and mechanics."
    elevation_angle_not_estimated: "Elevation max|min angle not estimated yet. Start elevation angle estimation to use automatic angle calculation."
    elevation_target_calculation_deactivated: "Auto elevation target angle calculation is deactivated. Activate \"Auto calculate elevation angle\" to fix this."
    elevation_control_deactivated: "Elevation angle control is deactivated. Activate \"Auto control elevation angle\" to fix this."
    elevation_boot_activation_deactivated: "Elevation angle control auto activation is deactivated. Activate \"Auto control elevation angle activation at boot\" to fix this."
    elevation_motor_wrong_direction: "ERROR: Elevation motor rotates in wrong direction! Motor direction is inverted. Enable \"Invert elevation motor direction\" to fix this."
    elevation_target_angle_timeout: "ERROR: Elevation target angle not reached within configured timeout! Check motor and mechanics or increase timeout value."
    magnetic_declination_calibration_active: "Magnetic declination calibration active..."
    azimuth_measurement_active: "Azimuth angle boundaries measurement active..."
    azimuth_measurement_fault: "Azimuth angle measurement failed. Check the motor and mechanics."
    azimuth_endstop_distance_invalid: "Azimuth angle measurement validation failed: Endstop distance out of tolerance. Expected ~225° but measured distance is invalid. Mechanical issue detected - check axis alignment."
    magnetic_declination_calibration_fault: "Magnetic declination calibration failed."
    azimuth_angle_not_estimated: "Azimuth max|min angle not estimated yet. Start azimuth angle estimation to use automatic angle calculation."
    azimuth_target_calculation_deactivated: "Auto azimuth target angle calculation is deactivated. Activate \"Auto calculate azimuth angle\" to fix this."
    azimuth_control_deactivated: "Azimuth angle control is deactivated. Activate \"Auto control azimuth angle\" to fix this."
    azimuth_boot_activation_deactivated: "Azimuth angle control auto activation is deactivated. Activate \"Auto control azimuth angle activation at boot\" to fix this."
    azimuth_motor_wrong_direction: "ERROR: Azimuth motor rotates in wrong direction! Motor direction is inverted. Enable \"Invert azimuth motor direction\" to fix this."
    azimuth_target_angle_timeout: "ERROR: Azimuth target angle not reached within configured timeout! Check motor and mechanics or increase timeout value."
    motor_blocked_high_current: "Motor blocked state detected(high current). Movement stopped & automatic controls deactivated."
    motor_connection_error_elevation: "Motor connection error detected (low current). Please check wiring!"
    motor_connection_error_rotation: "Motor connection error detected (low current). Please check wiring!"
    motor_blocked_angle_cw_not_changing: "Motor blocked state detected(angle CW not changing). Movement stopped."
    motor_blocked_angle_ccw_not_changing: "Motor blocked state detected(angle CCW not changing). Movement stopped."
    motor_blocked_angle_up_not_changing: "Motor blocked state detected while lifting (angle up not changing). Movement stopped."
    motor_blocked_angle_down_not_changing: "Motor blocked state detected while lifting (angle down not changing). Movement stopped."
    gnss_not_ready: "GNSS not ready."
    gnss_signal_quality_poor: "The GNSS signal quality is poor. Try to improve reception conditions."
    imu_not_ready: "IMU not ready."

  # Web frontend sorting settings - Organizes entities into logical groups and control their display order
  sorting_groups:
    # Sorting weights define the display order in the web frontend UI - Lower numbers appear first
    sorting_weight:
      status_overview: 1                        # Status overview group - System health and status summary
      fault_and_measurements_detection: 2       # Fault and measurements group - Shows all fault detection and measurement status
      safety_features_and_automations: 3        # Safety automation controls group - Motor protection and safety features
      system: 4                                 # System settings group - Device system info, restart, reset options
      stand_by_mode: 5                          # Standby mode settings group - Park position and automatic standby controls
      elevation_axis: 6                         # Elevation axis control group - Up/down motor controls and status
      azimuth_axis: 7                           # Azimuth axis control group - Rotation motor controls and status
      owm_weather_settings: 8                   # OpenWeatherMap weather settings group - Weather API and cloud/wind automations
      network_and_internet: 9                   # Network and internet group - WiFi, IP, and internet connection status
      gnss_sensor_status: 10                    # GNSS/GPS sensor group - Satellite positions and GNSS quality metrics
      time_sensor_status: 11                    # Time synchronization group - RTC, NTP, and GNSS time sources
      imu_sensor_status: 12                     # IMU/compass sensor group - Accelerometer, magnetic heading, and orientation
      elevation_motor_status: 13                # Elevation motor detailed status group - Current, voltage, and temperature
      azimuth_motor_status: 14                  # Azimuth motor detailed status group - Current, voltage, and temperature
      display_status: 15                        # Display settings group - LED brightness and display rotation
      buttons: 16                               # Physical button controls group - Manual button states
      invert_panel_pitch_angle_switch: 17       # Panel inversion toggle group - Manually flip elevation angle if mounted inverted
      
    # Sub-group organization within safety features
    safety_features_and_automations:
      auto_motor_connection_error_detection_on_off: 1  # Motor connection error detection enable/disable
      auto_motor_block_detection_on_off: 2            # Motor stuck/blocked detection enable/disable
      auto_panel_block_detection_by_angle_on_off: 3   # Panel movement fault detection enable/disable
      auto_motor_direction_detection_on_off: 4        # Motor wrong direction detection enable/disable
      auto_elevation_target_angle_timeout_detection_on_off: 5  # Elevation target angle timeout detection enable/disable
      auto_azimuth_target_angle_timeout_detection_on_off: 6    # Azimuth target angle timeout detection enable/disable
      magnetic_calibration_periodic_check_enabled: 7        # Periodic magnetic declination calibration check enable/disable
      auto_stand_by_mode_estimation: 8                      # Auto stand by mode estimation enable/disable
      auto_cloudy_mode_control: 9                           # Auto cloudy mode control enable/disable
      auto_stand_by_mode_via_sun_elevation_control: 10      # Auto stand by mode by sun elevation enable/disable
      auto_wind_protection_control: 11                      # Auto wind protection control enable/disable
      auto_owm_data_retrieval: 12                           # Auto OWM data retrieval enable/disable
      auto_control_elevation_angle_activation_at_boot: 13   # Auto control elevation angle activation at boot
      auto_control_elevation_angle: 14                      # Auto control elevation angle enable/disable
      auto_control_azimuth_angle_activation_at_boot: 15     # Auto control azimuth angle activation at boot
      auto_control_azimuth_angle: 16                        # Auto control azimuth angle enable/disable
      auto_set_panel_elev_target_to_sun_elev: 17            # Auto calculate elevation angle enable/disable
      auto_set_panel_azimuth_target_to_sun_azimuth: 18      # Auto calculate azimuth angle enable/disable
      auto_set_gnss_coordinates_to_device_coordinates: 19    # Auto set GNSS coordinates to device coordinates enable/disable
      auto_set_compass_heading_to_device_azimuth_orientation: 20  # Auto device azimuth orientation retrieval
      auto_stand_by_mode_if_owm_data_expired_control: 21  # Auto stand by mode if OWM data expired enable/disable
      axis_control_mode: 22                                 # Axis control mode selection (single/dual axis)
    
    # Motor status entity grouping and ordering
    motor_status:
      auto_motor_connection_error_detection_on_off: 1
      auto_motor_block_detection_on_off: 2
      auto_panel_block_detection_by_angle_on_off: 3
      auto_motor_direction_detection_on_off: 4

      elevation_motor_sensor_ready: 4
      motor_elevation_supply_current: 4
      motor_elevation_supply_power: 5
      motor_elevation_supply_voltage: 6
      motor_elevation_shunt_voltage:  7

      elevation_motor_blocked_current_threshold: 8
      elevation_motor_voltage_is_valid: 8 
      elevation_motor_is_blocked_binary_sensor: 9
      elevation_motor_is_running_binary_sensor: 10
      elevation_motor_is_idle: 11

      azimuth_motor_sensor_ready: 12
      motor_azimuth_supply_current: 12
      motor_azimuth_supply_power: 13
      motor_azimuth_supply_voltage: 14
      motor_azimuth_shunt_voltage: 15

      azimuth_motor_blocked_current_threshold: 16
      azimuth_motor_voltage_is_valid: 16
      azimuth_motor_is_running_binary_sensor: 17
      azimuth_motor_is_idle: 18
      azimuth_motor_is_blocked_binary_sensor: 19  
      
    # Physical button control grouping
    buttons:
      button_up_cw_physical: 1                  # Up/Clockwise physical button
      button_up_ccw_physical: 2                 # Down/Counter-clockwise physical button
      
    # Fault detection and measurement status grouping
    fault_and_measurements_detection:
      measurement_or_calibration_active: 1
      elev_angle_boundaries_measurement_active: 2
      azimuth_angle_boundaries_measurement_active: 3
      magnetic_declination_calibration_active: 4
      elevation_axis_not_calibrated: 5
      elevation_angle_max_min_not_estimated: 6
      elevation_angle_calculation_fault_detected: 7
      elevation_motor_blocked_current: 8
      elevation_motor_not_connected_low_current: 9
      elevation_motor_no_angle_change_lift: 10
      elevation_motor_no_angle_change_lowering: 11
      elevation_motor_wrong_direction_detected: 12
      elevation_target_angle_timeout_detected: 13
      azimuth_axis_not_calibrated: 14
      azimuth_angle_max_min_not_estimated: 15
      azimuth_angle_calculation_fault_detected: 16
      azimuth_motor_blocked_current: 17
      azimuth_motor_not_connected_low_current: 18
      azimuth_motor_no_angle_change_cw: 19
      azimuth_motor_no_angle_change_ccw: 20
      azimuth_motor_wrong_direction_detected: 21
      azimuth_target_angle_timeout_detected: 22
      magnetic_declination_calibration_fault_detected: 23
      
    # System status overview group - High-level status text for each major subsystem
    status_overview:
      elevation_motor_sensor_status_text: 1
      azimuth_motor_sensor_status_text: 2
      elevation_motor_status_text: 3
      azimuth_motor_status_text: 4
      elevation_axis_status_text: 5
      azimuth_axis_status_text: 6
      imu_status_text: 7
      owm_status_text: 8
      network_and_internet_status_text: 9
      gnss_status_text: 10
      
    # Network and internet connectivity grouping
    network_and_internet:
      id_ip_address: 1
      id_connected_ssid: 2
      id_connected_bssid: 3
      id_mac_wifi_address: 4
      wifi_signal_db: 5
      wifi_signal_percent: 6
      wifi_connected_binary_sensor: 7
      connection_test_url: 8
      test_internet_connection: 9
      internet_connection_available: 10
      id_latest_wifi_scan_results: 11
      
    # GNSS/GPS position and quality grouping
    gnss_sensor_status:
      gnss_sensor_ready: 1
      gnss_position_valid: 2
      gnss_reception_rating: 3
      gnss_reception_quality: 4
      gnss_satelites: 5
      gnss_hdop: 6
      gnss_latitude: 7
      gnss_longitude: 8
      gnss_altitude: 9
      device_latitude: 10
      device_longitude: 11
      auto_set_gnss_coordinates_to_device_coordinates: 12
      
    # Time source synchronization grouping
    time_sensor_status:
      ds3231_sensor_ready: 1
      ds3231_time: 2
      ntp_time: 3
      gnss_time: 4
      homeassistant_api_time: 5
      
    # OpenWeatherMap API and weather automation grouping
    weather_settings:
      owm_api_key_entered: 1
      owm_api_key: 2
      owm_api_key_valid: 3
      last_owm_retrieval_success: 4
      get_owm_data: 5
      owm_data_is_old: 6
      owm_data_is_expired: 7
      auto_owm_data_retrieval: 8
      cloud_coverage_current: 9
      cloud_coverage_in_one_hour: 10
      cloudy_mode_activation_threshold: 11
      owm_cloud_coverage_above_threshold: 12
      cloudy_mode_active: 13
      auto_cloudy_mode_control: 14
      wind_speed_current: 15
      wind_gusts_current: 16
      wind_speed_in_one_hour: 17
      wind_gusts_in_one_hour: 18
      wind_speed_protection_activation_threshold: 19
      wind_gusts_protection_activation_threshold: 20
      owm_wind_speed_above_threshold: 21
      owm_wind_gusts_above_threshold: 22
      auto_wind_protection_control: 23
      
    # System-wide settings and diagnostics grouping
    system:
      timezone: 0
      restart_esp: 1
      factory_reset_button: 2
      delete_wifi_credentials: 3
      logger_select: 4
      cpu_frequency_id: 5
      uptime_id: 6
      device_info_id: 7
      reset_reason_id: 8
      esphome_project_version_text_short: 9
      sunchronizer_firmware_version_text_detailed: 10
      version_id: 11
      heap_free_psram_id: 12
      free_psram_percent: 13
      heap_free_id: 14
      free_heap_percent: 15
      heap_max_block_id: 16
      heap_loop_time_id: 17

    # IMU accelerometer and magnetic heading grouping
    imu_sensor_status:
      imu_sensor_ready: 1
      panel_pitch: 2
      panel_imu_pitch: 3
      panel_imu_roll: 4
      panel_imu_yaw: 5
      accel_panel_x: 6
      accel_panel_y: 7
      accel_panel_z: 8
      imu_tilt_description: 9
      panel_orientation: 10
      magnetic_declination: 11
      save_current_magnetic_declination: 12
      invert_panel_pitch_angle_switch: 13
      magnetic_calibration_periodic_check_interval_minutes: 14
      perform_magnetic_declination_calibration_button: 25
      
    # Elevation axis motor control and status grouping
    elevation_axis:
      button_up_frontend: 1
      button_stop_frontend: 2
      button_down_frontend: 3
      axis_control_mode: 4
      auto_control_elevation_angle_activation_at_boot: 5
      auto_control_elevation_angle: 6
      panel_elev_target_angle: 7
      panel_elev_target_angle_tolerance: 8
      panel_elevation_angle_sensor: 9
      panel_elevation_angle_min: 10
      panel_elevation_angle_max: 11
      top_virtual_endstop_binary_sensor: 12
      bottom_virtual_endstop_binary_sensor: 13
      panel_lifting_planned: 14
      panel_lowering_planned: 15
      panel_lifting_active: 16
      panel_lowering_active: 17
      panel_lifting_to_elev_target_angle_needed_binary_sensor: 18
      panel_lowering_to_elev_target_angle_needed_binary_sensor: 19
      panel_within_elev_target_angle_range_binary_sensor: 20
      auto_set_panel_elev_target_to_sun_elev: 21
      elevation_motor_direction_inverted: 22
      elevation_axis_mode_activated: 23
      start_elev_angle_measurement: 24
      
    # Azimuth axis motor control and status grouping
    azimuth_axis:
      button_rotate_clockwise_frontend: 1
      button_rotation_stop_frontend: 2
      button_rotate_ccw_frontend: 3
      start_rot_angle_measurement: 4
      auto_control_azimuth_angle_activation_at_boot: 5
      auto_control_azimuth_angle: 6
      panel_azimuth_target_angle: 7
      panel_azimuth_target_angle_tolerance: 8
      panel_azimuth_orientation: 9
      panel_azimuth_angle_min: 10
      panel_azimuth_angle_max: 11
      azimuth_endstop_max_ccw_pos: 12
      azimuth_endstop_max_cw_pos: 13
      panel_rotation_in_cw_planned: 14
      panel_rotation_in_ccw_planned: 15
      panel_rotation_in_cw_active: 16
      panel_rotation_in_ccw_active: 17
      panel_left_from_azimuth_target_angle_binary_sensor: 18
      panel_right_from_azimuth_target_angle_binary_sensor: 19
      panel_within_azimuth_target_angle_range_binary_sensor: 20
      auto_set_panel_azimuth_target_to_sun_azimuth: 21
      azimuth_motor_direction_inverted: 23
      get_owm_data: 24
      
    # Display LED and screen settings grouping
    display_status:
      display_on_off: 1
      display_rotation_select: 2
      led_internal_brightness_day: 3
      led_external_brightness_day: 4
      led_internal_brightness_night: 5
      led_external_brightness_night: 6
      
    # Standby/park mode automatic control grouping
    standby_mode:
      auto_stand_by_mode_estimation: 1
      stand_by_mode_active: 2
      auto_stand_by_mode_via_sun_elevation_control: 3
      stand_by_mode_azimuth_target_angle: 4
      stand_by_mode_elevation_target_angle: 5
      sun_elevation_angle_below_stand_by_mode_threshold: 6
      panel_is_in_stand_by_position: 7
      stand_by_mode_elevation_trigger_angle: 8
      sun_azimuth: 9
      sun_elevation: 10
      stand_by_mode_trigger_high_winds: 11
      stand_by_mode_trigger_expired_owm_data: 12
      stand_by_mode_trigger_sun_elevation: 13

# =============================================================================================================================

external_components:
  - source:
      type: local
      path: my_components

esphome:
  name: ${name}
  friendly_name: ${fiendly_name}
  name_add_mac_suffix: ${add_mac_to_name}
  min_version: ${minimum_esphome_version}
  #platformio_options:
  #  build_flags: -DBOARD_HAS_PSRAM
  #  board_build.arduino.memory_type: qio_opi
  #  board_build.f_flash: 160000000L
  #  board_build.flash_mode: qio   
  includes:
    - <esp_timer.h>    # this is done to make the usage of esp_timer_get_time() possible (as a replacement for millis())

  project:
    name: ${project_name}
    version: ${firmware_version}    

  on_boot:
    - priority: 250
      then:
        - select.set:
            id: logger_select
            option: "ERROR"

    - priority: -200
      then:
        # to read the time directly after boot from rtc
        - ds3231.read_time:

        - lambda: |-
            // This is done to reload the previous setting of the display rotation select component
            auto call = id(display_rotation_select).make_call();
            switch (id(global_display_rotation)) {
              case DISPLAY_ROTATION_0_DEGREES: 
                call.set_option("0°");
                call.perform();
                break;
              case DISPLAY_ROTATION_90_DEGREES: 
                call.set_option("90°");
                call.perform();
                break;
              case DISPLAY_ROTATION_180_DEGREES: 
                call.set_option("180°");
                call.perform();
                break;     
              case DISPLAY_ROTATION_270_DEGREES: 
                call.set_option("270°");
                call.perform();
                break;       
              default:
                call.set_option("0°");
                call.perform();
            }

        # do an initial elevation- and azimuth-angle calculation after boot
        - script.execute: perform_inital_angle_state_initialization 

        # do an initial weather data retrieval after boot 
        - script.execute: perform_openweathermap_data_retrieval 

esp32:
  board: esp32-s3-devkitc-1
  framework:
    #type: arduino
    type: esp-idf
  cpu_frequency: ${cpu_frequency}

# Enable logging
logger:
  level: VERBOSE

#mqtt:
#  broker: ${mqtt.broker_url}
#  username: ${mqtt.broker_username}
#  password: ${mqtt.broker_password}

# Enable Home Assistant API
api:
  reboot_timeout: ${api_reboot_timeout}
  #encryption:                                             # uncomment to activate API encryption
  #  key: ${api_key}                                       # uncomment to activate API encryption

ota:
  - platform: esphome
    password: "${ota_password}"    # uncomment to activate password protection for OTA    
    on_begin:
      then:
        - lambda: |-
            ESP_LOGE("OTA:", "OTA process started. All axis stopped.");
        - script.execute: perform_deactivate_all_automatic_axis_controls
  - platform: web_server  

wifi:
  id: wifi_pyh_id
  #ssid: !secret wifi_ssid
  #password: !secret wifi_password
  output_power: 20dB
  power_save_mode: none
  use_psram: true
  min_auth_mode: WPA2
  enable_btm: true
  enable_rrm: true

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:

tinyusb:
  id: "usb_id"
  usb_product_id: 0x4001
  usb_vendor_id: 0x303A
  usb_lang_id: 0x0409
  usb_manufacturer_str: "Nerdiy"
  usb_product_str: "Sunchronizer"
  # usb_serial_str (Optional, string): Serial number string descriptor. If not specified, the device’s MAC address will be used.

improv_serial:

captive_portal:
    
uart:
  - id: gnss_uart
    rx_pin: ${gpio.gnss_rx}
    tx_pin: ${gpio.gnss_tx}
    baud_rate: ${gnss_baud_rate}

  - id: bno085_uart
    rx_pin: ${gpio.bno085_rx}
    tx_pin: ${gpio.bno085_tx}
    baud_rate: ${bno085_baud_rate}
    rx_buffer_size: 512
    parity: NONE
    stop_bits: 1
    data_bits: 8

mcp23017:
  - id: 'mcp23017_main'
    address: ${i2c_address.mcp23017}

interval:
  - interval: 250ms
    then:
      - lambda: |-
          yield();
          if (id(auto_control_elevation_angle).state)
          {
            id(perform_automatic_elevation_angle_adjustment).execute();
            id(perform_elevation_target_angle_timeout_check).execute();
          }
          yield();

          if (id(auto_control_azimuth_angle).state)
          {
            id(perform_automatic_azimuth_angle_adjustment).execute();
            id(perform_azimuth_target_angle_timeout_check).execute();
          }
          yield();

          id(perform_motor_blocked_check).execute();          
          yield();

          id(perform_motor_connection_error_check).execute();          
          yield();  

          id(perform_panel_movement_plausible_check).execute();          
          yield();

  - interval: 5s
    then:
      - lambda: |-
          yield();
          id(perform_sun_elevation_target_angle_calculation).execute();
          yield();
          id(perform_sun_azimuth_target_angle_calculation).execute();
          yield();

  - interval: 1min
    then:
      # check if stand by mode needs to be activated/deactivated
      - script.execute: perform_stand_by_mode_activation_check    

  - interval: ${owm_data_retrieval_check_period}
    then:
      # do a periodic weather data retrieval (if activated and stand by mode is not active)
      # - as soon as the current cloud coverage value is updated it also checks if the cloudy mode needs to be enabled or disabled.
      # - as soon as the current wind speed and gusts value is updated it also checks if the stand by mode needs to be enabled or disabled.
      - lambda: |-
          if (id(auto_owm_data_retrieval).state && !id(stand_by_mode_active).state)
          {
            id(perform_openweathermap_data_retrieval_if_owm_data_is_old).execute();
          }

  - interval: ${status_text_sensor_update_interval}
    startup_delay: 30s
    then:
      script.execute: perform_publish_states_to_status_text_sensors

  - interval: ${magnetic_calibration_periodic_check_interval_seconds}s  # Periodic magnetic calibration check interval
    then:
      - if:
          condition:
            - lambda: 'return id(magnetic_calibration_periodic_check_enabled).state;'
          then:
            - script.execute: check_if_magnetic_declination_calibration_is_needed_periodic

  - interval: ${status_led_update_interval}
    then:
      script.execute: perform_status_led_update

  - interval: ${internet_connection_test_interval}
    startup_delay: 1min
    then:
      script.execute: perform_internet_connection_test

  - interval: ${mcu_led_blink_interval}
    then:
      light.toggle: mcu_led

i2c:
  sda: ${gpio.sda}
  scl: ${gpio.scl}
  scan: true
  id: i2c_main
    
web_server:
  port: ${webserver.port}
  version: 3
  id: web_server_standard
  # auth:                             # uncomment to activate user/password protection for webserver
      # username: "${webserver.user}"       # uncomment to activate user/password protection for webserver
      # password: "${webserver.password}"   # uncomment to activate user/password protection for webserver
  local: true
  sorting_groups:  
    - id: sorting_group_safety_features_and_automations
      name: "Safety features & automations"
      sorting_weight: ${sorting_groups.sorting_weight.safety_features_and_automations}
    - id: sorting_group_weather_settings
      name: "Weather settings"
      sorting_weight: ${sorting_groups.sorting_weight.owm_weather_settings}
    - id: sorting_group_fault_and_measurements_detection
      name: "Fault & Measurement detections"
      sorting_weight: ${sorting_groups.sorting_weight.fault_and_measurements_detection}
    - id: sorting_group_elevation_axis
      name: "Elevation (Up/Down) Axis"
      sorting_weight: ${sorting_groups.sorting_weight.elevation_axis}
    - id: sorting_group_azimuth_axis
      name: "Azimuth (Rotation) Axis"
      sorting_weight: ${sorting_groups.sorting_weight.azimuth_axis}
    - id: sorting_group_gnss_sensor_status
      name: "GNSS Status"
      sorting_weight: ${sorting_groups.sorting_weight.gnss_sensor_status}   
    - id: sorting_group_time_sensor_status
      name: "Time Status"
      sorting_weight: ${sorting_groups.sorting_weight.time_sensor_status}  
    - id: sorting_group_imu_sensor_status
      name: "IMU Status"
      sorting_weight: ${sorting_groups.sorting_weight.imu_sensor_status}   
    - id: sorting_group_elevation_motor_status
      name: "Elevation Motor Status"
      sorting_weight: ${sorting_groups.sorting_weight.elevation_motor_status} 
    - id: sorting_group_azimuth_motor_status
      name: "Azimuth Motor Status"
      sorting_weight: ${sorting_groups.sorting_weight.azimuth_motor_status} 
    - id: sorting_group_display_status
      name: "Display & LED Settings"
      sorting_weight: ${sorting_groups.sorting_weight.display_status} 
    - id: sorting_group_network_and_internet
      name: "Network & Internet"
      sorting_weight: ${sorting_groups.sorting_weight.network_and_internet} 
    - id: sorting_group_standby_mode
      name: "StandBy Mode"
      sorting_weight: ${sorting_groups.sorting_weight.stand_by_mode} 
    - id: sorting_group_status_overview
      name: "Status overview"
      sorting_weight: ${sorting_groups.sorting_weight.status_overview} 
    - id: sorting_group_system
      name: "System"
      sorting_weight: ${sorting_groups.sorting_weight.system} 
    - id: sorting_group_buttons
      name: "Buttons"
      sorting_weight: ${sorting_groups.sorting_weight.buttons} 

#runtime_stats:
#  log_interval: 20s

time:
  - platform: sntp
    id: sntp_time
    timezone: ${timezone}
    servers:
     - ${url.ntp_server1}
     - ${url.ntp_server2}
     - ${url.ntp_server3}
    on_time_sync:
      then:
        - logger.log: "Synchronized system clock via NTP" 
        - ds3231.write_time: 

  - platform: homeassistant
    id: homeassistant_time
    timezone: ${timezone}
    on_time_sync:
      then:
        - logger.log: "Synchronized system clock via HomeAssistant" 
        - ds3231.write_time:

  - platform: gps
    id: gnss_time  
    timezone: ${timezone}
    on_time_sync:
      then:
        - logger.log: "Synchronized system clock via GNSS" 
        - ds3231.write_time:
          
  - platform: ds3231
    id: ds3231_time
    timezone: ${timezone}
    address: ${i2c_address.ds3231}
    update_interval: 30s
    temperature:
      name: "DS3231 RTC temperature"
      id: ds3231_temperature_sensor
      icon: "mdi:temperature-celsius"
      web_server:
        sorting_group_id: sorting_group_system
        sorting_weight: 3    

debug:
  update_interval: 5s

text_sensor:

  - platform: template
    name: "Timezone"
    id: timezone
    lambda: |-
      return {"${timezone}"};
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: ${sorting_groups.system.timezone}

# Error sensors

  - platform: template
    name: "Azimuth Motor status"
    id: azimuth_motor_status_text
    icon: "mdi:alert-circle"
    lambda: |-
      return {"Normal"};
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_status_overview
      sorting_weight: ${sorting_groups.status_overview.azimuth_motor_status_text}
    on_value:
      - lambda: |-
          ESP_LOGE("Azimuth Motor status:", "Changed to: %s", id(azimuth_motor_status_text).state.c_str());

  - platform: template
    name: "Elevation Motor status"
    id: elevation_motor_status_text
    icon: "mdi:alert-circle"
    lambda: |-
      return {"Normal"};
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_status_overview
      sorting_weight: ${sorting_groups.status_overview.elevation_motor_status_text}
    on_value:
      - lambda: |-
          ESP_LOGE("Elevation Motor status:", "Changed to: %s", id(elevation_motor_status_text).state.c_str());

  - platform: template
    name: "Elevation Motor sensor status"
    id: elevation_motor_sensor_status_text
    icon: "mdi:alert-circle"
    lambda: |-
      return {"Normal"};
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_status_overview
      sorting_weight: ${sorting_groups.status_overview.azimuth_motor_sensor_status_text}
    on_value:
      - lambda: |-
          ESP_LOGE("Elevation Motor sensor status:", "Changed to: %s", id(elevation_motor_sensor_status_text).state.c_str());

  - platform: template
    name: "Azimuth Motor sensor status"
    id: azimuth_motor_sensor_status_text
    icon: "mdi:alert-circle"
    lambda: |-
      return {"Normal"};
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_status_overview
      sorting_weight: ${sorting_groups.status_overview.elevation_motor_sensor_status_text}
    on_value:
      - lambda: |-
          ESP_LOGE("Azimuth Motor sensor status:", "Changed to: %s", id(azimuth_motor_sensor_status_text).state.c_str());

  - platform: template
    name: "IMU status"
    id: imu_status_text
    icon: "mdi:alert-circle"
    lambda: |-
      return {"Normal"};
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_status_overview
      sorting_weight: ${sorting_groups.status_overview.imu_status_text}
    on_value:
      - lambda: |-
          ESP_LOGE("IMU status:", "Changed to: %s", id(imu_status_text).state.c_str());

  - platform: template
    name: "Elevation Axis status"
    id: elevation_axis_status_text
    icon: "mdi:alert-circle"
    lambda: |-
      return {"Normal"};
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_status_overview
      sorting_weight: ${sorting_groups.status_overview.elevation_axis_status_text}
    on_value:
      - lambda: |-
          ESP_LOGE("Elevation angle status:", "Changed to: %s", id(elevation_axis_status_text).state.c_str());

  - platform: template
    name: "Azimuth Axis status"
    id: azimuth_axis_status_text
    icon: "mdi:alert-circle"
    lambda: |-
      return {"Normal"};
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_status_overview
      sorting_weight: ${sorting_groups.status_overview.azimuth_axis_status_text}
    on_value:
      - lambda: |-
          ESP_LOGE("Azimuth angle status:", "Changed to: %s", id(azimuth_axis_status_text).state.c_str());

  - platform: template
    name: "OWM status"
    id: owm_status_text
    icon: "mdi:alert-circle"
    lambda: |-
      return {"Normal"};
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_status_overview
      sorting_weight: ${sorting_groups.status_overview.owm_status_text}
    on_value:
      - lambda: |-
          ESP_LOGE("OWM status:", "Changed to: %s", id(owm_status_text).state.c_str());

  - platform: template
    name: "Network & Internet status"
    id: network_and_internet_status_text
    icon: "mdi:alert-circle"
    lambda: |-
      return {"Normal"};
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_status_overview
      sorting_weight: ${sorting_groups.status_overview.network_and_internet_status_text}
    on_value:
      - lambda: |-
          ESP_LOGE("Network & Internet status:", "Changed to: %s", id(network_and_internet_status_text).state.c_str());

  - platform: template
    name: "GNSS status"
    id: gnss_status_text
    icon: "mdi:alert-circle"
    lambda: |-
      return {"Normal"};
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_status_overview
      sorting_weight: ${sorting_groups.status_overview.gnss_status_text}
    on_value:
      - lambda: |-
          ESP_LOGE("GNSS status:", "Changed to: %s", id(gnss_status_text).state.c_str());

# System related sensors

  - platform: template
    name: "Sunchronizer Firmware Version"
    id: esphome_project_version_text_short
    icon: "mdi:information-box"
    entity_category: "diagnostic"
    update_interval: 600s
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: ${sorting_groups.system.esphome_project_version_text_short}
    lambda: |-
      return { ESPHOME_PROJECT_VERSION };

  - platform: template
    name: "Sunchronizer Firmware compile time"
    id: sunchronizer_firmware_version_text_detailed
    icon: "mdi:information-box"
    entity_category: "diagnostic"
    update_interval: 600s
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: ${sorting_groups.system.sunchronizer_firmware_version_text_detailed}
    lambda: |-
      return { ESPHOME_PROJECT_VERSION " " + App.get_compilation_time() };

  - platform: template
    name: "PCB Version"
    id: pcb_version
    icon: "mdi:circuit-board"
    entity_category: "diagnostic"
    update_interval: 600s
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 2
    lambda: |-
      return { "${made_for_pcb_version}" };

  - platform: version
    name: "ESPHome Version"
    id: version_id
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: ${sorting_groups.system.version_id}

  - platform: debug
    device:
      name: "Device Info"
      id: device_info_id
      web_server:
        sorting_group_id: sorting_group_system
        sorting_weight: ${sorting_groups.system.device_info_id}

    reset_reason:
      name: "Reset Reason"
      id: reset_reason_id
      web_server:
        sorting_group_id: sorting_group_system
        sorting_weight: ${sorting_groups.system.reset_reason_id}

# Network and internet related sensors

  - platform: wifi_info
    ip_address:
      name: "IP Address"
      id: id_ip_address
      web_server:
        sorting_group_id: sorting_group_network_and_internet
        sorting_weight: ${sorting_groups.network_and_internet.id_ip_address}
    ssid:
      name: "Connected SSID"
      id: id_connected_ssid
      icon: "mdi:wifi"
      web_server:
        sorting_group_id: sorting_group_network_and_internet
        sorting_weight: ${sorting_groups.network_and_internet.id_connected_ssid}
    bssid:
      name: "Connected BSSID"
      id: id_connected_bssid
      icon: "mdi:wifi"
      web_server:
        sorting_group_id: sorting_group_network_and_internet
        sorting_weight: ${sorting_groups.network_and_internet.id_connected_bssid}
    mac_address:
      name: "Mac Wifi Address"
      id: id_mac_wifi_address
      web_server:
        sorting_group_id: sorting_group_network_and_internet
        sorting_weight: ${sorting_groups.network_and_internet.id_mac_wifi_address}
    scan_results:
      name: "Latest WiFi Scan Results"
      id: id_latest_wifi_scan_results
      icon: "mdi:wifi-settings"
      disabled_by_default: true
      web_server:
        sorting_group_id: sorting_group_network_and_internet
        sorting_weight: ${sorting_groups.network_and_internet.id_latest_wifi_scan_results}
  
  # GNSS related sensors

  - platform: template
    name: "GNSS Reception Rating"
    id: gnss_reception_rating
    icon: "mdi:map-marker-check"
    update_interval: 30s
    web_server:
      sorting_group_id: sorting_group_gnss_sensor_status
      sorting_weight: ${sorting_groups.gnss_sensor_status.gnss_reception_rating}
    lambda: |-
      if (isnan(id(gnss_hdop).state) || isnan(id(gnss_satelites).state)) {
        return {"No data available. Currently set coordinates will be used."};
      }
      
      const float hdop = id(gnss_hdop).state;
      const int sats = (int) id(gnss_satelites).state;

      if (sats < 4) {
        return {"Poor reception (less than 4 satellites)"};
      } else if (hdop < 1.0) {
        return {"Excellent reception"};
      } else if (hdop < 2.0) {
        return {"Good reception"};
      } else if (hdop < 5.0) {
        return {"Fair reception"};
      } else {
        return {"Poor reception"};
      }

# Time related sensors

  - platform: template
    name: "DS3231 Time"
    id: ds3231_time_text
    lambda: |-
            char str[17];
            time_t currTime = id(ds3231_time).now().timestamp;
            strftime(str, sizeof(str), "%d.%m.%Y %H:%M", localtime(&currTime));
            return  { str };
    update_interval: 60s
    web_server:
      sorting_group_id: sorting_group_time_sensor_status
      sorting_weight: ${sorting_groups.time_sensor_status.ds3231_time}
    icon: "mdi:clock-time-four-outline"

  - platform: template
    name: "NTP Time"
    id: ntp_time_text
    lambda: |-
            char str[17];
            time_t currTime = id(sntp_time).now().timestamp;
            strftime(str, sizeof(str), "%d.%m.%Y %H:%M", localtime(&currTime));
            return  { str };
    update_interval: 60s
    web_server:
      sorting_group_id: sorting_group_time_sensor_status
      sorting_weight: ${sorting_groups.time_sensor_status.ntp_time}
    icon: "mdi:clock-time-four-outline"

  - platform: template
    name: "GNSS Time"
    id: gnss_time_text
    lambda: |-
            char str[17];
            time_t currTime = id(gnss_time).now().timestamp;
            strftime(str, sizeof(str), "%d.%m.%Y %H:%M", localtime(&currTime));
            return  { str };
    update_interval: 60s
    web_server:
      sorting_group_id: sorting_group_time_sensor_status
      sorting_weight: ${sorting_groups.time_sensor_status.gnss_time}
    icon: "mdi:clock-time-four-outline"

  - platform: template
    name: "HomeAssistant API Time"
    id: homeassistant_api_time_text
    lambda: |-
            char str[17];
            time_t currTime = id(homeassistant_time).now().timestamp;
            strftime(str, sizeof(str), "%d.%m.%Y %H:%M", localtime(&currTime));
            return  { str };
    update_interval: 60s
    web_server:
      sorting_group_id: sorting_group_time_sensor_status
      sorting_weight: ${sorting_groups.time_sensor_status.homeassistant_api_time}
    icon: "mdi:clock-time-four-outline"    

# OWM related sensors

  - platform: template
    name: "Last OWM retrieval success"
    id: last_owm_retrieval_success
    icon: "mdi:update"
    web_server:
      sorting_group_id: sorting_group_weather_settings
      sorting_weight: ${sorting_groups.weather_settings.last_owm_retrieval_success}
    lambda: |-
      if (id(global_owm_last_data_retrieval_success) == 0) 
      {
        return {"Never"};
      } else 
      {
        char str[17];
        time_t currTime = id(global_owm_last_data_retrieval_success);
        strftime(str, sizeof(str), "%d.%m.%Y %H:%M", localtime(&currTime)); 
        return {str};
      }
    update_interval: 60s

# IMU related sensors

  - platform: template
    name: "Last magnetic declination calibration"
    id: last_magnetic_calibration_text
    icon: mdi:calendar-clock
    update_interval: 60s
    web_server:
      sorting_group_id: sorting_group_imu_sensor_status
      sorting_weight: ${sorting_groups.imu_sensor_status.imu_tilt_description}
    lambda: |-
      if (id(global_last_magnetic_calibration_success) == 0) 
      {
        return {"Not yet calibrated"};
      }

      time_t ts = id(global_last_magnetic_calibration_success);
      struct tm *t = localtime(&ts);

      char buffer[32];
      strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", t);
      return {buffer};


  - platform: template
    name: "IMU Tilt Description"
    id: imu_tilt_description
    icon: "mdi:tilt-remote"
    disabled_by_default: false
    web_server:
      sorting_group_id: sorting_group_imu_sensor_status
      sorting_weight: ${sorting_groups.imu_sensor_status.imu_tilt_description}
    update_interval: 1s
    lambda: |-
      float pitch = id(panel_imu_pitch).state;  // previously calculated
      float roll = id(panel_imu_roll).state;    // previously calculated

      std::string description;

      // Pitch description
      if (pitch < -30) {
        description += "strong forward tilt";
      } else if (pitch < -10) {
        description += "slight forward tilt";
      } else if (pitch > 30) {
        description += "strong backward tilt";
      } else if (pitch > 10) {
        description += "slight backward tilt";
      } else {
        description += "level pitch";
      }

      description += ", ";

      // Roll description
      if (roll < -30) {
        description += "strong right tilt";
      } else if (roll < -10) {
        description += "slight right tilt";
      } else if (roll > 30) {
        description += "strong left tilt";
      } else if (roll > 10) {
        description += "slight left tilt";
      } else {
        description += "level roll";
      }

      return description;

  - platform: template
    name: "Panel Orientation"
    id: panel_orientation
    icon: "mdi:compass"
    update_interval: 1s
    web_server:
      sorting_group_id: sorting_group_imu_sensor_status
      sorting_weight: ${sorting_groups.imu_sensor_status.panel_orientation}
    lambda: |-
      float pitch = id(panel_pitch).state;
      float heading = id(panel_compass_heading).state;

      if (isnan(pitch) || isnan(heading)) {
        return {"Unknown"};
      }

      // Describe inclination
      std::string tilt_desc;
      if (pitch > 10) {
        tilt_desc = "Tilted Down";
      } else if (pitch < -10) {
        tilt_desc = "Tilted Up";
      } else {
        tilt_desc = "Flat";
      }

      // Cardinal direction based on heading
      std::string dir_desc;
      if (heading >= 337.5 || heading < 22.5) {
        dir_desc = "North";
      } else if (heading < 67.5) {
        dir_desc = "North-East";
      } else if (heading < 112.5) {
        dir_desc = "East";
      } else if (heading < 157.5) {
        dir_desc = "South-East";
      } else if (heading < 202.5) {
        dir_desc = "South";
      } else if (heading < 247.5) {
        dir_desc = "South-West";
      } else if (heading < 292.5) {
        dir_desc = "West";
      } else {
        dir_desc = "North-West";
      }

      char buffer[64];
      snprintf(buffer, sizeof(buffer), "%s (%.1f°), %s (%.1f°)", tilt_desc.c_str(), pitch, dir_desc.c_str(), heading);
      return {buffer};


text:

  - platform: template
    name: "OpenWeatherMap API key"
    id: owm_api_key
    mode: password
    restore_value: true
    entity_category: "config"
    initial_value: ${initial_value.initial_owm_key_value}
    optimistic: true
    web_server:
      sorting_group_id: sorting_group_weather_settings
      sorting_weight: ${sorting_groups.weather_settings.owm_api_key}

  - platform: template
    name: "Connection test URL"
    id: connection_test_url
    mode: text
    restore_value: true
    entity_category: "config"
    initial_value: ${url.initial_connection_test_url}
    optimistic: true
    web_server:
      sorting_group_id: sorting_group_network_and_internet
      sorting_weight: ${sorting_groups.network_and_internet.connection_test_url}

gps:
  id: gnss_receiver
  uart_id: gnss_uart
  latitude:
    name: "GNSS Latitude"
    id: gnss_latitude
    icon: "mdi:crosshairs-gps"
    disabled_by_default: false
    web_server:
      sorting_group_id: sorting_group_gnss_sensor_status
      sorting_weight: ${sorting_groups.gnss_sensor_status.gnss_latitude}
    on_value:
      then:
        lambda: |-
          if (id(auto_set_gnss_coordinates_to_device_coordinates).state and id(gnss_position_valid).state)
          {
            auto call = id(device_latitude).make_call();
            call.set_value(x);
            call.perform();
          }
  longitude:
    name: "GNSS Longitude"
    id: gnss_longitude
    icon: "mdi:crosshairs-gps"
    disabled_by_default: false
    web_server:
      sorting_group_id: sorting_group_gnss_sensor_status
      sorting_weight: ${sorting_groups.gnss_sensor_status.gnss_longitude}
    on_value:
      then:
        lambda: |-
          if (id(auto_set_gnss_coordinates_to_device_coordinates).state and id(gnss_position_valid).state)
          {
            auto call = id(device_longitude).make_call();
            call.set_value(x);
            call.perform();
          }
  altitude:
    name: "GNSS Altitude"
    id: gnss_altitude
    disabled_by_default: true
    web_server:
      sorting_group_id: sorting_group_gnss_sensor_status
      sorting_weight: ${sorting_groups.gnss_sensor_status.gnss_altitude}
  satellites:
    name: "GNSS Satelites"
    id: gnss_satelites
    icon: "mdi:satellite-variant"
    disabled_by_default: true
    web_server:
      sorting_group_id: sorting_group_gnss_sensor_status
      sorting_weight: ${sorting_groups.gnss_sensor_status.gnss_satelites}
  hdop:
    name: "GNSS HDOP"
    id: gnss_hdop
    disabled_by_default: true
    icon: "mdi:crosshairs-question"
    web_server:
      sorting_group_id: sorting_group_gnss_sensor_status
      sorting_weight: ${sorting_groups.gnss_sensor_status.gnss_hdop}

sun:
  id: sun_data
  latitude: ${coordinates.standard_latitude}
  longitude: ${coordinates.standard_longitude}

http_request:
  verify_ssl: "${http_request_ssl_verification}"
  useragent: esphome/device
  timeout: 10s
  id: http_request_data

button:
  - platform: restart
    name: "Restart ESP"
    id: restart_esp
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: ${sorting_groups.system.restart_esp}

  - platform: factory_reset
    name: "Factory reset"
    id: factory_reset_button
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: ${sorting_groups.system.factory_reset_button}

  - platform: template
    name: "Delete Wifi credentials"
    id: delete_wifi_credentials
    icon: "mdi:wifi-cancel"
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: ${sorting_groups.system.delete_wifi_credentials}
    on_press:
      then:
        - wifi.configure:
            ssid: "DeletedWifi"
            password: ""
            save: true
        - button.press: restart_esp

  - platform: template
    name: "Save current magnetic declination"
    id: save_current_magnetic_declination
    entity_category: "config"
    web_server:
      sorting_group_id: sorting_group_imu_sensor_status
      sorting_weight: ${sorting_groups.imu_sensor_status.save_current_magnetic_declination}
    on_press:
      then:
        - script.execute: 
            id: perform_save_current_magnetic_declination

  - platform: template
    name: "Perform magnetic declination calibration"
    id: perform_magnetic_declination_calibration_button
    icon: "mdi:compass-calibration"
    entity_category: "config"
    web_server:
      sorting_group_id: sorting_group_imu_sensor_status
      sorting_weight: ${sorting_groups.imu_sensor_status.perform_magnetic_declination_calibration_button}
    on_press:
      then:
        - script.execute: 
            id: perform_magnetic_declination_calibration

  - platform: template
    name: "Start elevation angle measurement"
    id: start_elev_angle_measurement
    icon: "mdi:tape-measure"
    entity_category: "config"
    web_server:
      sorting_group_id: sorting_group_elevation_axis
      sorting_weight: ${sorting_groups.elevation_axis.start_elev_angle_measurement}
    on_press:
      then:
        - script.execute: 
            id: perform_automatic_elev_angle_boundaries_measurement   

  - platform: template
    name: "Start Azimuth angle measurement"
    id: start_rot_angle_measurement
    icon: "mdi:tape-measure"
    entity_category: "config"
    web_server:
      sorting_group_id: sorting_group_azimuth_axis
      sorting_weight: ${sorting_groups.azimuth_axis.start_rot_angle_measurement}
    on_press:
      then:
        - script.execute: perform_automatic_azimuth_angle_boundaries_measurement 

  - platform: template
    name: "Panel Lifter Up"
    id: button_up_frontend
    icon: "mdi:arrow-expand-up"
    web_server:
      sorting_group_id: sorting_group_elevation_axis
      sorting_weight: ${sorting_groups.elevation_axis.button_up_frontend}
    on_press:
      then:
        - switch.turn_off: auto_control_elevation_angle
        - switch.turn_off: auto_cloudy_mode_control
        - script.execute: start_panel_lifting

  - platform: template
    name: "Panel Lifter Down"
    id: button_down_frontend
    icon: "mdi:arrow-expand-down"
    web_server:
      sorting_group_id: sorting_group_elevation_axis
      sorting_weight: ${sorting_groups.elevation_axis.button_down_frontend}
    on_press:
      then:
        - switch.turn_off: auto_control_elevation_angle
        - switch.turn_off: auto_cloudy_mode_control       
        - script.execute: start_panel_lowering

  - platform: template
    name: "Panel Lifter Stop"
    id: button_stop_frontend
    icon: "mdi:stop-circle-outline"
    web_server:
      sorting_group_id: sorting_group_elevation_axis
      sorting_weight: ${sorting_groups.elevation_axis.button_stop_frontend}
    on_press:
      then:
        - switch.turn_off: auto_control_elevation_angle
        - switch.turn_off: auto_cloudy_mode_control
        - script.execute: stop_panel_elevation_movement
        - script.execute: perform_stop_any_running_calibration

  - platform: template
    name: "Panel Rotation CCW"
    id: button_rotate_ccw_frontend
    icon: "mdi:rotate-left"
    web_server:
      sorting_group_id: sorting_group_azimuth_axis
      sorting_weight: ${sorting_groups.azimuth_axis.button_rotate_ccw_frontend}
    on_press:
      then:
        - switch.turn_off: auto_control_azimuth_angle
        - switch.turn_off: auto_cloudy_mode_control
        - script.execute: start_panel_rotation_counterclockwise

  - platform: template
    name: "Panel Rotation CW"
    id: button_rotate_clockwise_frontend
    icon: "mdi:rotate-right"
    web_server:
      sorting_group_id: sorting_group_azimuth_axis
      sorting_weight: ${sorting_groups.azimuth_axis.button_rotate_clockwise_frontend}
    on_press:
      then:
        - switch.turn_off: auto_control_azimuth_angle
        - switch.turn_off: auto_cloudy_mode_control
        - script.execute: start_panel_rotation_clockwise

  - platform: template
    name: "Panel Rotation Stop"
    id: button_rotation_stop_frontend
    icon: "mdi:stop-circle-outline"
    web_server:
      sorting_group_id: sorting_group_azimuth_axis
      sorting_weight: ${sorting_groups.azimuth_axis.button_rotation_stop_frontend}
    on_press:
      then:
        - switch.turn_off: auto_control_azimuth_angle
        - switch.turn_off: auto_cloudy_mode_control
        - script.execute: stop_panel_rotation_movement
        - script.execute: perform_stop_any_running_calibration

  - platform: template
    name: "Retrieve OWM data"
    id: get_owm_data
    icon: "mdi:cloud-download"
    web_server:
      sorting_group_id: sorting_group_weather_settings
      sorting_weight: ${sorting_groups.weather_settings.get_owm_data}
    on_press:
      then:
        - lambda: |-
            id(perform_openweathermap_data_retrieval).execute();        

  - platform: template
    name: "Test internet connection"
    id: test_internet_connection
    icon: "mdi:lan-connect"
    web_server:
      sorting_group_id: sorting_group_network_and_internet
      sorting_weight: ${sorting_groups.network_and_internet.test_internet_connection}
    on_press:
      then:
        - lambda: |-
            id(perform_internet_connection_test).execute();     

 # This is only needed for testing the feature
 # - platform: template
 #   name: "Reset magnetic declination calibration timestamp"
 #   on_press:
 #     then:
 #       - lambda: |-
 #           id(global_last_magnetic_calibration_success) = 0;
 #           id(last_magnetic_calibration_text).update();

switch:

 # GPIO output switches
 # The outputs for the motor control GPIOs are defined here as switches to be able to use the interlock functionality.
 # Additionally: In the past two cover configurations were used to control the rotation and lifting. This did not work properly due to false initial state after boot that blocks the needed movement.

  - platform: gpio
    id: motor_elevation_plus_pin
    internal: true
    interlock: [motor_elevation_minus_pin]
    pin:
      mcp23xxx: mcp23017_main
      number: ${gpio_ids.motor_elevation_plus}
      mode:
        output: true
      inverted: true

  - platform: gpio
    id: motor_elevation_minus_pin
    internal: true
    interlock: [motor_elevation_plus_pin]
    pin:
      mcp23xxx: mcp23017_main
      number: ${gpio_ids.motor_elevation_minus}
      mode:
        output: true
      inverted: true

  - platform: gpio
    id: motor_azimuth_plus_pin
    internal: true
    interlock: [motor_azimuth_minus_pin]
    pin:
      mcp23xxx: mcp23017_main
      number: ${gpio_ids.motor_azimuth_plus}
      mode:
        output: true
      inverted: true

  - platform: gpio
    id: motor_azimuth_minus_pin
    internal: true
    interlock: [motor_azimuth_plus_pin]
    pin:
      mcp23xxx: mcp23017_main
      number: ${gpio_ids.motor_azimuth_minus}
      mode:
        output: true
      inverted: true

 # Other

  - platform: template
    name: "Display On|Off"
    id: display_on_off
    icon: "mdi:monitor"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF 
    web_server:
      sorting_group_id: sorting_group_display_status
      sorting_weight: ${sorting_groups.display_status.display_on_off}
    on_turn_on:
      - lambda: |-
          ESP_LOGE("Switches", "\"Display On|Off\" enabled.");
    on_turn_off:
      - lambda: |-
          ESP_LOGE("Switches", "\"Display On|Off\" disabled.");

  # If this is activated the StandBy Mode will be automatically activated/deactivated based on the current conditions
  - platform: template
    name: "Auto Stand By Mode estimation"
    id: auto_stand_by_mode_estimation
    icon: "mdi:sleep"
    optimistic: True
    restore_mode: RESTORE_DEFAULT_OFF
    web_server:
      sorting_group_id: sorting_group_safety_features_and_automations
      sorting_weight: ${sorting_groups.safety_features_and_automations.auto_stand_by_mode_estimation}
    on_turn_on:
      - lambda: |-
          ESP_LOGE("Switches", "\"Auto Stand By Mode estimation\" enabled.");      
          id(perform_stand_by_mode_activation_check).execute();               
    on_turn_off:
      - lambda: |-
          ESP_LOGE("Switches", "\"Auto Stand By Mode estimation\" disabled."); 
          id(perform_stand_by_mode_activation_check).execute();   

  # If this mode is active the panel will be lowered to the lowest possible elevation angle 
  - platform: template
    name: "Stand By Mode Active"
    id: stand_by_mode_active
    icon: "mdi:sleep"
    optimistic: True
    restore_mode: RESTORE_DEFAULT_OFF
    web_server:
      sorting_group_id: sorting_group_standby_mode
      sorting_weight: ${sorting_groups.standby_mode.stand_by_mode_active}
    on_turn_on:
      - lambda: |-
          ESP_LOGE("Switches", "\"Stand By Mode Active\" enabled."); 
          id(perform_sun_elevation_target_angle_calculation).execute();  
          id(perform_sun_azimuth_target_angle_calculation).execute();                    
    on_turn_off:
      - lambda: |-
          ESP_LOGE("Switches", "\"Stand By Mode Active\" disabled."); 
          id(perform_sun_elevation_target_angle_calculation).execute();
          id(perform_sun_azimuth_target_angle_calculation).execute();
          id(perform_openweathermap_data_retrieval_if_owm_data_is_old).execute();   // in case the standby mode was inactive for long time (and therefore the data retrieval) this triggers a new data retrieval
      - script.execute: check_if_magnetic_declination_calibration_is_needed    # in case there was no magnetic declination calibration today it will be executed now
      - script.wait: check_if_magnetic_declination_calibration_is_needed

  # If this mode is active the panel will be lowered to 0° elevation angle to maximize the power output during cloudy weather conditions
  # It will be activated automatically if the cloudiness reaches the threshold
  - platform: template
    name: "Cloudy Mode Active"
    id: cloudy_mode_active
    icon: "mdi:cloud-outline"
    optimistic: True
    restore_mode: RESTORE_DEFAULT_OFF
    web_server:
      sorting_group_id: sorting_group_weather_settings
      sorting_weight: ${sorting_groups.weather_settings.cloudy_mode_active}
    on_turn_on:
      - lambda: |-
          ESP_LOGE("Switches", "\"Cloudy Mode Active\" enabled.");
          id(perform_sun_elevation_target_angle_calculation).execute();  
          id(perform_sun_azimuth_target_angle_calculation).execute();                    
    on_turn_off:
      - lambda: |-
          ESP_LOGE("Switches", "\"Cloudy Mode Active\" disabled.");
          id(perform_sun_elevation_target_angle_calculation).execute();
          id(perform_sun_azimuth_target_angle_calculation).execute();

  # If this is activated the cloudy mode is automatically activated when the retrieved cloudiness value reaches the threshold
  - platform: template
    name: "Auto cloudy mode On|Off"
    id: auto_cloudy_mode_control
    icon: "mdi:cloud-outline"
    optimistic: True
    restore_mode: RESTORE_DEFAULT_OFF
    web_server:
      sorting_group_id: sorting_group_safety_features_and_automations
      sorting_weight: ${sorting_groups.safety_features_and_automations.auto_cloudy_mode_control}
    on_turn_off:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto cloudy mode On|Off\" disabled.");  
    on_turn_on:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto cloudy mode On|Off\" enabled."); 
            id(perform_automatic_cloudy_mode_control_estimation).execute();

  # If this is activated the stand by mode is automatically acitvated as soon as the sun elevation angle is below the trigger angle
  - platform: template
    name: "Auto stand by mode by sun elevation"
    id: auto_stand_by_mode_via_sun_elevation_control
    icon: "mdi:sleep"
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_group_safety_features_and_automations
      sorting_weight: ${sorting_groups.safety_features_and_automations.auto_stand_by_mode_via_sun_elevation_control}
    on_turn_off:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto stand by mode by sun elevation\" disabled.");  
    on_turn_on:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto stand by mode by sun elevation\" enabled."); 
      - script.execute: perform_stand_by_mode_activation_check

  # If this is activated the motor connection error detection check is active. If a motor is powered but the motor current does not behave accordingly this will be detected.
  - platform: template
    name: "Fault detection motor connection error"
    id: auto_motor_connection_error_detection_on_off
    icon: "mdi:weather-windy"
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_group_safety_features_and_automations
      sorting_weight: ${sorting_groups.safety_features_and_automations.auto_motor_connection_error_detection_on_off}
    on_turn_off:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto motor connection error detection On|Off\" disabled.");  
    on_turn_on:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto motor connection error detection On|Off\" enabled."); 

  # If this is activated the motor block check is active. If a motor is powered and the motor current is too high this will be detected as fault.
  - platform: template
    name: "Fault detection motor blocked"
    id: auto_motor_block_detection_on_off
    icon: "mdi:weather-windy"
    optimistic: True
    restore_mode: ALWAYS_ON   # This should always be on after boot to avoid that the controller gets stuck in a boot loop due to a blocked motor -> high current -> power supply shutdown -> reboot ...
    web_server:
      sorting_group_id: sorting_group_safety_features_and_automations
      sorting_weight: ${sorting_groups.safety_features_and_automations.auto_motor_block_detection_on_off}
    on_turn_off:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto motor block detection On|Off\" disabled.");  
    on_turn_on:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto motor block detection On|Off\" enabled."); 

  # If this is activated the panel block check is active. If a panel is planned to move and does not accordingly this will be detected as fault.
  - platform: template
    name: "Fault detection panel blocked"
    id: auto_panel_block_detection_by_angle_on_off
    icon: "mdi:weather-windy"
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_group_safety_features_and_automations
      sorting_weight: ${sorting_groups.safety_features_and_automations.auto_panel_block_detection_by_angle_on_off}
    on_turn_off:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto panel block detection On|Off\" disabled.");  
    on_turn_on:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto panel block detection On|Off\" enabled."); 

  # If this is activated periodic magnetic calibration checks are performed at the configured interval
  - platform: template
    name: "Periodic magnetic calibration check enabled"
    id: magnetic_calibration_periodic_check_enabled
    icon: "mdi:magnet"
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_group_safety_features_and_automations
      sorting_weight: ${sorting_groups.safety_features_and_automations.magnetic_calibration_periodic_check_enabled}
    on_turn_off:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Periodic magnetic calibration check enabled\" disabled.");  
    on_turn_on:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Periodic magnetic calibration check enabled\" enabled."); 

  # If this is activated the motor wrong direction detection is active. If a motor rotates in the opposite direction this will be detected.
  - platform: template
    name: "Fault detection motor wrong direction"
    id: auto_motor_direction_detection_on_off
    icon: "mdi:rotate-left-variant"
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_group_safety_features_and_automations
      sorting_weight: 4
    on_turn_off:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto motor direction detection On|Off\" disabled.");  
    on_turn_on:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto motor direction detection On|Off\" enabled.");

  # If this is activated the elevation target angle timeout detection is active. If target angle is not reached within timeout period this will be detected.
  - platform: template
    name: "Fault detection elevation target angle timeout"
    id: auto_elevation_target_angle_timeout_detection_on_off
    icon: "mdi:timer-alert"
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_group_safety_features_and_automations
      sorting_weight: 5
    on_turn_off:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto elevation target angle timeout detection On|Off\" disabled.");  
    on_turn_on:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto elevation target angle timeout detection On|Off\" enabled.");

  # If this is activated the azimuth target angle timeout detection is active. If target angle is not reached within timeout period this will be detected.
  - platform: template
    name: "Fault detection azimuth target angle timeout"
    id: auto_azimuth_target_angle_timeout_detection_on_off
    icon: "mdi:timer-alert"
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_group_safety_features_and_automations
      sorting_weight: 6
    on_turn_off:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto azimuth target angle timeout detection On|Off\" disabled.");  
    on_turn_on:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto azimuth target angle timeout detection On|Off\" enabled."); 

  # If this is activated the cloudy mode is automatically activated when the retrieved cloudiness value reaches the threshold
  - platform: template
    name: "Auto stand by mode at high winds On|Off"
    id: auto_wind_protection_control
    icon: "mdi:weather-windy"
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_group_safety_features_and_automations
      sorting_weight: ${sorting_groups.safety_features_and_automations.auto_wind_protection_control}
    on_turn_off:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto stand by mode at high winds On|Off\" disabled.");  
    on_turn_on:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto stand by mode at high winds On|Off\" enabled."); 
      - script.execute: perform_stand_by_mode_activation_check

  # If this is enabled the stand by mode is activated if data retrieval fails for some time (defined in owm_data_expiration_shutdown_time)
  - platform: template
    name: "Auto stand by mode if OWM data expired"
    id: auto_stand_by_mode_if_owm_data_expired_control
    icon: "mdi:cable-data"
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_group_safety_features_and_automations
      sorting_weight: ${sorting_groups.safety_features_and_automations.auto_stand_by_mode_if_owm_data_expired_control}
    on_turn_off:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto stand by mode if OWM data expired\" disabled.");  
    on_turn_on:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto stand by mode if OWM data expired\" enabled."); 
      - script.execute: perform_stand_by_mode_activation_check

  - platform: template
    name: "Auto OWM data retrieval"
    id: auto_owm_data_retrieval
    icon: "mdi:cable-data"
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_group_safety_features_and_automations
      sorting_weight: ${sorting_groups.safety_features_and_automations.auto_owm_data_retrieval}
    on_turn_off:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto OWM data retrieval\" disabled.");  
    on_turn_on:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto OWM data retrieval\" enabled."); 
      - script.execute: perform_openweathermap_data_retrieval

  - platform: template
    name: "Auto control elevation angle activation at boot"
    id: auto_control_elevation_angle_activation_at_boot
    icon: "mdi:angle-acute"
    optimistic: True
    entity_category: "config"
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_group_safety_features_and_automations
      sorting_weight: ${sorting_groups.safety_features_and_automations.auto_control_elevation_angle_activation_at_boot}
    on_turn_off:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto control elevation angle activation at boot\" disabled."); 
    on_turn_on:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto control elevation angle activation at boot\" enabled."); 

  - platform: template
    name: "Auto control elevation angle"
    id: auto_control_elevation_angle
    icon: "mdi:angle-acute"
    optimistic: True
    entity_category: "config"
    restore_mode: ALWAYS_OFF    # this is done to have the automatic controls off at boot up so that the new target angle can be calculated first before any movement is started. The Auto control switch is activated automatically as soon as the caluclation data is valid
    web_server:
      sorting_group_id: sorting_group_safety_features_and_automations
      sorting_weight: ${sorting_groups.safety_features_and_automations.auto_control_elevation_angle}
    on_turn_off:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto control elevation angle\" disabled."); 
      - script.execute: stop_panel_elevation_movement   
    on_turn_on:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto control elevation angle\" enabled.");
            // Reset timeout tracking when enabling auto control
            id(global_elevation_target_angle_timeout_start_timestamp) = 0;
            id(global_elevation_target_angle_timeout_detected) = false; 

  - platform: template
    name: "Auto control azimuth angle activation at boot"
    id: auto_control_azimuth_angle_activation_at_boot
    icon: "mdi:angle-acute"
    optimistic: True
    entity_category: "config"
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_group_safety_features_and_automations
      sorting_weight: ${sorting_groups.safety_features_and_automations.auto_control_azimuth_angle_activation_at_boot}
    on_turn_off:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto control azimuth angle activation at boot\" disabled.");  
    on_turn_on:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto control azimuth angle activation at boot\" enabled."); 

  - platform: template
    name: "Auto control azimuth angle"
    id: auto_control_azimuth_angle
    icon: "mdi:angle-acute"
    optimistic: True
    entity_category: "config"
    restore_mode: ALWAYS_OFF    # this is done to have the automatic controls off at boot up so that the new target angle can be calculated first before any movement is started. The Auto control switch is activated automatically as soon as the caluclation data is valid
    web_server:
      sorting_group_id: sorting_group_safety_features_and_automations
      sorting_weight: ${sorting_groups.safety_features_and_automations.auto_control_azimuth_angle}
    on_turn_off:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto control azimuth angle\" disabled.");    
      - script.execute: stop_panel_rotation_movement
    on_turn_on:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto control azimuth angle\" enabled.");
            // Reset timeout tracking when enabling auto control
            id(global_azimuth_target_angle_timeout_start_timestamp) = 0;
            id(global_azimuth_target_angle_timeout_detected) = false; 

  - platform: template
    name: "Auto calculate elevation angle"
    id: auto_set_panel_elev_target_to_sun_elev
    icon: "mdi:sun-angle-outline"
    optimistic: True
    entity_category: "config"
    restore_mode: RESTORE_DEFAULT_ON 
    web_server:
      sorting_group_id: sorting_group_safety_features_and_automations
      sorting_weight: ${sorting_groups.safety_features_and_automations.auto_set_panel_elev_target_to_sun_elev}
    on_turn_on:
      - lambda: |-
          ESP_LOGE("Switches", "\"Auto calculate elevation angle\" enabled.");
          id(perform_sun_elevation_target_angle_calculation).execute();
    on_turn_off:
      - lambda: |-
          ESP_LOGE("Switches", "\"Auto calculate elevation angle\" disabled.");

  - platform: template
    name: "Auto calculate azimuth angle"
    id: auto_set_panel_azimuth_target_to_sun_azimuth
    icon: "mdi:sun-angle-outline"
    optimistic: True
    entity_category: "config"
    restore_mode: RESTORE_DEFAULT_ON 
    web_server:
      sorting_group_id: sorting_group_safety_features_and_automations
      sorting_weight: ${sorting_groups.safety_features_and_automations.auto_set_panel_azimuth_target_to_sun_azimuth}
    on_turn_on:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto calculate azimuth angle\" enabled."); 
            id(perform_sun_azimuth_target_angle_calculation).execute();
    on_turn_off:
      - lambda: |-       
            ESP_LOGE("Switches", "\"Auto calculate azimuth angle\" disabled.");    

  - platform: template
    name: "Auto device coordinates retrieval"
    id: auto_set_gnss_coordinates_to_device_coordinates
    icon: "mdi:longitude"
    optimistic: True
    entity_category: "config"
    restore_mode: RESTORE_DEFAULT_ON 
    web_server:
      sorting_group_id: sorting_group_safety_features_and_automations
      sorting_weight: ${sorting_groups.safety_features_and_automations.auto_set_gnss_coordinates_to_device_coordinates}
    on_turn_on:
      - lambda: |-
          ESP_LOGE("Switches", "\"Auto device coordinates retrieval\" enabled.");
    on_turn_off:
      - lambda: |-
          ESP_LOGE("Switches", "\"Auto device coordinates retrieval\" disabled.");

  - platform: template
    name: "Auto device azimuth orientiation retrieval"
    id: auto_set_compass_heading_to_device_azimuth_orientation
    icon: "mdi:sun-compass"
    optimistic: True
    entity_category: "config"
    restore_mode: RESTORE_DEFAULT_ON 
    web_server:
      sorting_group_id: sorting_group_safety_features_and_automations
      sorting_weight: ${sorting_groups.safety_features_and_automations.auto_set_compass_heading_to_device_azimuth_orientation}
    on_turn_on:
      - lambda: |-
          ESP_LOGE("Switches", "\"Auto device azimuth orientiation retrieval\" enabled.");
    on_turn_off:
      - lambda: |-
          ESP_LOGE("Switches", "\"Auto device azimuth orientiation retrieval\" disabled.");

 # If this is enabled the panel pitch angle will be inverted
  - platform: template
    name: "Invert Panel pitch angle"
    id: invert_panel_pitch_angle_switch
    icon: "mdi:angle-acute"
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON
    web_server:
      sorting_group_id: sorting_group_imu_sensor_status
      sorting_weight: ${sorting_groups.imu_sensor_status.invert_panel_pitch_angle_switch}

 # If this is enabled the aziuth motor direction is inverted
  - platform: template
    name: "Azimuth motor direction inverted"
    id: azimuth_motor_direction_inverted
    icon: "mdi:rotate-3d-variant"
    optimistic: True
    restore_mode: RESTORE_DEFAULT_OFF
    web_server:
      sorting_group_id: sorting_group_azimuth_axis
      sorting_weight: ${sorting_groups.azimuth_axis.azimuth_motor_direction_inverted}

 # If this is enabled the elevation motor direction is inverted
  - platform: template
    name: "Elevation motor direction inverted"
    id: elevation_motor_direction_inverted
    icon: "mdi:rotate-3d-variant"
    optimistic: True
    restore_mode: RESTORE_DEFAULT_OFF
    web_server:
      sorting_group_id: sorting_group_elevation_axis
      sorting_weight: ${sorting_groups.elevation_axis.elevation_motor_direction_inverted}

number:

  - platform: template
    name: "LED internal brightness day"
    id: led_internal_brightness_day
    icon: "mdi:brightness-5"
    max_value: 100
    min_value: 20
    step: 1
    initial_value: ${initial_value.led_internal_brightness_day}
    unit_of_measurement: "%"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: slider
    web_server:
      sorting_group_id: sorting_group_display_status
      sorting_weight: ${sorting_groups.display_status.led_internal_brightness_day}
    on_value: 
      then:        
        script.execute: perform_status_led_update

  - platform: template
    name: "LED external brightness day"
    id: led_external_brightness_day
    icon: "mdi:brightness-5"
    max_value: 100
    min_value: 20
    step: 1
    initial_value: ${initial_value.led_external_brightness_day}
    unit_of_measurement: "%"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: slider
    web_server:
      sorting_group_id: sorting_group_display_status
      sorting_weight: ${sorting_groups.display_status.led_external_brightness_day}
    on_value: 
      then:        
        script.execute: perform_status_led_update

  - platform: template
    name: "LED internal brightness night"
    id: led_internal_brightness_night
    icon: "mdi:brightness-2"
    max_value: 100
    min_value: 20
    step: 1
    initial_value: ${initial_value.led_internal_brightness_night}
    unit_of_measurement: "%"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: slider
    web_server:
      sorting_group_id: sorting_group_display_status
      sorting_weight: ${sorting_groups.display_status.led_internal_brightness_night}
    on_value: 
      then:        
        script.execute: perform_status_led_update

  - platform: template
    name: "LED external brightness night"
    id: led_external_brightness_night
    icon: "mdi:brightness-2"
    max_value: 100
    min_value: 20
    step: 1
    initial_value: ${initial_value.led_external_brightness_night}
    unit_of_measurement: "%"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: slider
    web_server:
      sorting_group_id: sorting_group_display_status
      sorting_weight: ${sorting_groups.display_status.led_external_brightness_night}
    on_value: 
      then:        
        script.execute: perform_status_led_update

  - platform: template
    name: "Azimuth motor blocked current threshold"
    id: azimuth_motor_blocked_current_threshold
    icon: "mdi:alert-circle"
    max_value: ${azimuth_motor_blocked_current_max}
    min_value: ${azimuth_motor_blocked_current_min}
    step: 0.01
    initial_value: ${initial_value.azimuth_motor_blocked_current_threshold}
    unit_of_measurement: "A"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: box
    web_server:
      sorting_group_id: sorting_group_azimuth_motor_status
      sorting_weight: ${sorting_groups.motor_status.azimuth_motor_blocked_current_threshold}

  - platform: template
    name: "Elevation motor blocked current threshold"
    id: elevation_motor_blocked_current_threshold
    icon: "mdi:alert-circle"
    max_value: ${elevation_motor_blocked_current_max}
    min_value: ${elevation_motor_blocked_current_min}
    step: 0.01
    initial_value: ${initial_value.elevation_motor_blocked_current_threshold}
    unit_of_measurement: "A"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: box
    web_server:
      sorting_group_id: sorting_group_elevation_motor_status
      sorting_weight: ${sorting_groups.motor_status.elevation_motor_blocked_current_threshold}

  - platform: template
    name: "Stand by mode elevation trigger angle"
    id: stand_by_mode_elevation_trigger_angle
    icon: "mdi:sleep"
    max_value: 100
    min_value: 10
    step: 1
    initial_value: ${initial_value.stand_by_mode_elevation_trigger_angle}
    unit_of_measurement: "°"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: box
    web_server:
      sorting_group_id: sorting_group_standby_mode
      sorting_weight: ${sorting_groups.standby_mode.stand_by_mode_elevation_trigger_angle}
    on_value: 
      then:
        - script.execute: perform_stand_by_mode_activation_check

  - platform: template
    name: "Cloudy mode activation threshold"
    id: cloudy_mode_activation_threshold
    icon: "mdi:cloud-percent"
    max_value: 100
    min_value: 10
    step: 1
    initial_value: ${initial_value.cloudy_mode_activation_threshold}
    unit_of_measurement: "%"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: box
    web_server:
      sorting_group_id: sorting_group_weather_settings
      sorting_weight: ${sorting_groups.weather_settings.cloudy_mode_activation_threshold}
    on_value: 
      then:
        - script.execute: perform_automatic_cloudy_mode_control_estimation    
        - script.execute: perform_stand_by_mode_activation_check  

  - platform: template
    name: "Wind speed protection activation threshold"
    id: wind_speed_protection_activation_threshold
    icon: "mdi:weather-windy"
    max_value: 100
    min_value: 1
    step: 1
    initial_value: ${initial_value.wind_speed_protection_activation_threshold}
    unit_of_measurement: "m/s"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: box
    web_server:
      sorting_group_id: sorting_group_weather_settings
      sorting_weight: ${sorting_groups.weather_settings.wind_speed_protection_activation_threshold}
    on_value: 
      then:
        - script.execute: perform_stand_by_mode_activation_check

  - platform: template
    name: "Wind gusts protection activation threshold"
    id: wind_gusts_protection_activation_threshold
    icon: "mdi:wind-power"
    max_value: 100
    min_value: 1
    step: 1
    initial_value: ${initial_value.wind_gusts_protection_activation_threshold}
    unit_of_measurement: "m/s"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: box
    web_server:
      sorting_group_id: sorting_group_weather_settings
      sorting_weight: ${sorting_groups.weather_settings.wind_gusts_protection_activation_threshold}
    on_value: 
      then:
        - script.execute: perform_stand_by_mode_activation_check

  - platform: template
    name: "Magnetic declination"
    id: magnetic_declination
    icon: "mdi:compass"
    max_value: 360
    min_value: -360
    step: 0.1
    initial_value: ${initial_value.magnetic_declination}   # in °
    unit_of_measurement: "°"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: box
    web_server:
      sorting_group_id: sorting_group_imu_sensor_status
      sorting_weight: ${sorting_groups.imu_sensor_status.magnetic_declination}
    on_value:
      then:
      - lambda: |-
          ESP_LOGE("Magnetic declination", "Declination set to %2.1f°.", x);

  - platform: template
    name: "Periodic magnetic calibration interval"
    id: magnetic_calibration_periodic_check_interval_minutes
    icon: "mdi:magnet"
    max_value: 1440
    min_value: 1
    step: 1
    initial_value: ${magnetic_calibration_periodic_check_interval_minutes}
    unit_of_measurement: "min"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: box
    web_server:
      sorting_group_id: sorting_group_imu_sensor_status
      sorting_weight: ${sorting_groups.imu_sensor_status.magnetic_calibration_periodic_check_interval_minutes}
    on_value:
      then:
      - lambda: |-
          ESP_LOGE("Periodic magnetic calibration interval", "Interval set to %d minutes.", (int)x);

  - platform: template
    name: "Stand by azimuth target angle"
    id: stand_by_mode_azimuth_target_angle
    icon: "mdi:sleep"
    max_value: 360
    min_value: 0
    step: 1.0
    initial_value: ${initial_value.stand_by_mode_azimuth_target_angle}   # in °
    unit_of_measurement: "°"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: box
    web_server:
      sorting_group_id: sorting_group_standby_mode
      sorting_weight: ${sorting_groups.standby_mode.stand_by_mode_azimuth_target_angle}

  - platform: template
    name: "Stand by elevtation target angle"
    id: stand_by_mode_elevation_target_angle
    icon: "mdi:sleep"
    max_value: 90
    min_value: 0
    step: 1.0
    initial_value: ${initial_value.stand_by_mode_elevation_target_angle}   # in °
    unit_of_measurement: "°"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: box
    web_server:
      sorting_group_id: sorting_group_standby_mode
      sorting_weight: ${sorting_groups.standby_mode.stand_by_mode_elevation_target_angle}

  - platform: template
    name: "Panel elevation angle max"
    id: panel_elevation_angle_max
    icon: "mdi:arrow-expand-up"
    max_value: 90
    min_value: -90
    step: 0.1
    initial_value: ${initial_value.panel_elev_angle_max}
    optimistic: true
    restore_value: true
    mode: box
    unit_of_measurement: "°"
    disabled_by_default: false
    web_server:
      sorting_group_id: sorting_group_elevation_axis
      sorting_weight: ${sorting_groups.elevation_axis.panel_elevation_angle_max}
    on_value:
      then:
      - lambda: |-
          if (x < id(panel_elevation_angle_min).state + 10)
          {
            //Error: 
            ESP_LOGE("main", "Error: \"Panel elevation angle max\" must be at least 10° bigger than \"Panel elevation angle min\"");

            float new_value = id(panel_elevation_angle_max).state - 10.0;
            
            auto call = id(panel_elevation_angle_min).make_call();
            call.set_value(new_value < ${initial_value.panel_elev_angle_min} ? ${initial_value.panel_elev_angle_min} : new_value );
            call.perform();
          }

  - platform: template
    name: "Panel elevation angle min"
    id: panel_elevation_angle_min
    icon: "mdi:arrow-expand-down"
    max_value: 90
    min_value: -90
    step: 0.1
    initial_value: ${initial_value.panel_elev_angle_min}
    optimistic: true
    restore_value: true
    mode: box
    unit_of_measurement: "°"
    disabled_by_default: false
    web_server:
      sorting_group_id: sorting_group_elevation_axis
      sorting_weight: ${sorting_groups.elevation_axis.panel_elevation_angle_min}
    on_value:
      then:
      # we set the stand by mode elevation target angle to the minimum possible. In most cases this makes the most sense.
      - lambda: |-
          auto call = id(stand_by_mode_elevation_target_angle).make_call();
          call.set_value(x);
          call.perform();
      - lambda: |-
          if (x > id(panel_elevation_angle_max).state - 10)
          {
            //Error: 
            ESP_LOGE("main", "Error: \"Panel elevation angle min\" must be at least 10° smaller than \"Panel elevation angle max\"");

            float new_value = id(panel_elevation_angle_min).state + 10.0;
            
            auto call = id(panel_elevation_angle_max).make_call();
            call.set_value(new_value > ${initial_value.panel_elev_angle_max} ? ${initial_value.panel_elev_angle_max} : new_value );
            call.perform();
          }

  - platform: template
    name: "Panel azimuth angle max"
    id: panel_azimuth_angle_max
    icon: "mdi:arrow-expand-right"
    max_value: 360
    min_value: 0
    step: 0.1
    initial_value: ${initial_value.panel_azimuth_angle_max}   # in °
    unit_of_measurement: "°"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: box
    web_server:
      sorting_group_id: sorting_group_azimuth_axis
      sorting_weight: ${sorting_groups.azimuth_axis.panel_azimuth_angle_max}
    on_value:
      then:
        - lambda: |-
            if (x < id(panel_azimuth_angle_min).state + 10)
            {
              //Error: 
              ESP_LOGE("main", "Error: \"Panel azimuth angle max\" must be at least 10° bigger than \"Panel azimuth angle min\"");

              float new_value = id(panel_azimuth_angle_max).state - 10.0;
              
              auto call = id(panel_azimuth_angle_min).make_call();
              call.set_value(new_value < ${initial_value.panel_azimuth_angle_min} ? ${initial_value.panel_azimuth_angle_min} : new_value );
              call.perform();
            }

  - platform: template
    name: "Panel azimuth angle min"
    id: panel_azimuth_angle_min
    icon: "mdi:arrow-expand-left"
    max_value: 360
    min_value: 0
    step: 0.1
    initial_value: ${initial_value.panel_azimuth_angle_min}   # in °
    unit_of_measurement: "°"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: box
    web_server:
      sorting_group_id: sorting_group_azimuth_axis
      sorting_weight: ${sorting_groups.azimuth_axis.panel_azimuth_angle_min}
    on_value:
      then:
        - lambda: |-
            if (x > id(panel_azimuth_angle_max).state - 10)
            {
              //Error: 
              ESP_LOGE("main", "Error: \"Panel azimuth angle min\" must be at least 10° smaller than \"Panel azimuth angle max\"");

              float new_value = id(panel_azimuth_angle_min).state + 10.0;
              
              auto call = id(panel_azimuth_angle_max).make_call();
              call.set_value(new_value > ${initial_value.panel_azimuth_angle_max} ? ${initial_value.panel_azimuth_angle_max} : new_value );
              call.perform();
            }

  - platform: template
    name: "Panel elevation target angle"
    id: panel_elev_target_angle
    icon: "mdi:target"
    max_value: 90
    min_value: -90
    step: 0.1
    unit_of_measurement: "°"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: box
    web_server:
      sorting_group_id: sorting_group_elevation_axis
      sorting_weight: ${sorting_groups.elevation_axis.panel_elev_target_angle}

  - platform: template
    name: "Panel elevation target angle tolerance"
    id: panel_elev_target_angle_tolerance
    icon: "mdi:swap-vertical"
    max_value: 20
    min_value: 1
    initial_value: ${initial_value.panel_elev_target_angle_tolerance}
    step: 0.1
    unit_of_measurement: "°"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: box
    web_server:
      sorting_group_id: sorting_group_elevation_axis
      sorting_weight: ${sorting_groups.elevation_axis.panel_elev_target_angle_tolerance}

  - platform: template
    name: "Panel azimuth target angle"
    id: panel_azimuth_target_angle
    icon: "mdi:target"
    max_value: 360
    min_value: 0
    step: 0.1
    unit_of_measurement: "°"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: box
    web_server:
      sorting_group_id: sorting_group_azimuth_axis
      sorting_weight: ${sorting_groups.azimuth_axis.panel_azimuth_target_angle}

  - platform: template
    name: "Panel azimuth target angle tolerance"
    id: panel_azimuth_target_angle_tolerance
    icon: "mdi:swap-horizontal"
    max_value: 20
    min_value: 1.5
    initial_value: ${initial_value.panel_azimuth_target_angle_tolerance}
    step: 0.1
    unit_of_measurement: "°"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: box
    web_server:
      sorting_group_id: sorting_group_azimuth_axis
      sorting_weight: ${sorting_groups.azimuth_axis.panel_azimuth_target_angle_tolerance}

  - platform: template
    name: "Panel azimuth orientation (manual)"  # The compass direction the panel is pointing to
    id: panel_azimuth_orientation
    max_value: 359.9
    min_value: 0
    step: 0.1
    initial_value: ${initial_value.panel_azimuth_orientation}
    unit_of_measurement: "°"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: box
    web_server:
      sorting_group_id: sorting_group_azimuth_axis
      sorting_weight: ${sorting_groups.azimuth_axis.panel_azimuth_orientation}

  - platform: template
    name: "Latitude"
    id: device_latitude
    icon: "mdi:latitude"
    max_value: 90.0
    min_value: -90.0
    step: 0.0001    # higher precision is not possible due to esphome limitations
    initial_value: ${coordinates.standard_latitude}
    unit_of_measurement: "°"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: box
    on_value:
      then:
        - lambda: |-
            id(sun_data).set_latitude(x);
    web_server:
      sorting_group_id: sorting_group_gnss_sensor_status
      sorting_weight: ${sorting_groups.gnss_sensor_status.device_latitude}

  - platform: template
    name: "Longitude"
    id: device_longitude
    icon: "mdi:longitude"
    max_value: 360.0
    min_value: 0.0
    step: 0.0001    # higher precision is not possible due to esphome limitations
    initial_value: ${coordinates.standard_longitude}
    unit_of_measurement: "°"
    optimistic: true
    restore_value: true
    entity_category: "config"
    mode: box
    on_value:
      then:
        - lambda: |-
            id(sun_data).set_longitude(x); 
    web_server:
      sorting_group_id: sorting_group_gnss_sensor_status
      sorting_weight: ${sorting_groups.gnss_sensor_status.device_longitude}

select:
  - platform: logger
    id: logger_select
    name: "Loglevel"
    icon: "mdi:format-list-bulleted"
    entity_category: "config"
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: ${sorting_groups.system.logger_select}

  - platform: template
    name: "Axis control mode"
    id: axis_control_mode
    icon: "mdi:axis-xyz-rotate-ccw"
    entity_category: "config"
    options:
      - "Elevation axis only"
      - "Elevation & Azimuth axis"
    optimistic: true
    restore_value: true
    web_server:
      sorting_group_id: sorting_group_safety_features_and_automations
      sorting_weight: ${sorting_groups.safety_features_and_automations.axis_control_mode}

  - platform: template
    name: "Display rotation"
    id: display_rotation_select
    options:
      - 0°
      - 180°
    initial_option: 0°
    optimistic: true
    entity_category: "config"
    web_server:
      sorting_group_id: sorting_group_display_status
      sorting_weight: ${sorting_groups.display_status.display_rotation_select}
    on_value:
      then:
        - logger.log:
             format: "Chosen option: %s "
             args: ["x.c_str()"]
        - lambda: |-   
            auto index = id(display_rotation_select).active_index();     
            ESP_LOGI("main", "Option at index %d is active", index.value());  
            if (index.value() == 0)
            {
              id(global_display_rotation) = DISPLAY_ROTATION_0_DEGREES;
              //id(display1).set_rotation(DISPLAY_ROTATION_0_DEGREES);
              ESP_LOGD("lambda", "Set rotation to 0°");
            } else if (index.value() == 1)
            {
              id(global_display_rotation) = DISPLAY_ROTATION_180_DEGREES;
              //id(display1).set_rotation(DISPLAY_ROTATION_180_DEGREES); 
              ESP_LOGD("lambda", "Set rotation to 180°");             
            } 
        #- component.update: display1

psram:
  mode: octal
  speed: 80MHz

sensor:
  - platform: debug
    free:
      name: "Free Heap"
      id: heap_free_id
      icon: "mdi:memory"
      web_server:
        sorting_group_id: sorting_group_system
        sorting_weight: ${sorting_groups.system.heap_free_id}
    block:
      name: "Heap Max Block"
      id: heap_max_block_id
      icon: "mdi:memory"
      web_server:
        sorting_group_id: sorting_group_system
        sorting_weight: ${sorting_groups.system.heap_max_block_id}
    loop_time:
      name: "Loop Time"
      id: heap_loop_time_id
      icon: "mdi:timer"
      web_server:
        sorting_group_id: sorting_group_system
        sorting_weight: ${sorting_groups.system.heap_loop_time_id}
    cpu_frequency:
      name: "CPU frequency"
      id: cpu_frequency_id
      icon: "mdi:speedometer"
      web_server:
        sorting_group_id: sorting_group_system
        sorting_weight: ${sorting_groups.system.cpu_frequency_id}
    psram:
      name: "Free PSRAM"
      id: heap_free_psram_id
      icon: "mdi:memory"
      web_server:
        sorting_group_id: sorting_group_system
        sorting_weight: ${sorting_groups.system.heap_free_psram_id}

  - platform: template
    name: "Free PSRAM (%)"
    id: free_psram_percent
    icon: "mdi:percent"
    unit_of_measurement: "%"
    accuracy_decimals: 1
    update_interval: 10s
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: ${sorting_groups.system.free_psram_percent}
    lambda: |-
      const float total_psram = int(${total_psram_in_bytes}); 
      if (id(heap_free_psram_id).state <= 0) return NAN;
      return (id(heap_free_psram_id).state / total_psram) * 100.0;

  - platform: template
    name: "Free Heap (%)"
    id: free_heap_percent
    icon: "mdi:percent"
    unit_of_measurement: "%"
    accuracy_decimals: 1
    update_interval: 10s
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: ${sorting_groups.system.free_heap_percent}
    lambda: |-
      const float total_heap = int(${total_heap_in_bytes});
      if (id(heap_free_id).state <= 0) return NAN;
      return (id(heap_free_id).state / total_heap) * 100.0;

  - platform: uptime
    name: Uptime
    id: uptime_id
    icon: "mdi:clock-outline"
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: ${sorting_groups.system.uptime_id}
  
  - platform: sun
    name: Sun Elevation
    id: sun_elevation
    type: elevation
    disabled_by_default: false
    web_server:
      sorting_group_id: sorting_group_standby_mode
      sorting_weight: ${sorting_groups.standby_mode.sun_elevation}
    on_value: 
      then:
        - script.execute: perform_inital_angle_state_initialization

  - platform: sun
    name: Sun Azimuth
    id: sun_azimuth
    type: azimuth
    disabled_by_default: true
    web_server:
      sorting_group_id: sorting_group_standby_mode
      sorting_weight: ${sorting_groups.standby_mode.sun_azimuth}
    on_value: 
      then:    
        - script.execute: perform_inital_angle_state_initialization 

  - platform: wifi_signal # Reports the WiFi signal strength/RSSI in dB
    name: "WiFi Signal dB"
    id: wifi_signal_db
    icon: "mdi:wifi-arrow-up-down"
    update_interval: 60s
    entity_category: "diagnostic"
    disabled_by_default: true
    web_server:
      sorting_group_id: sorting_group_network_and_internet
      sorting_weight: ${sorting_groups.network_and_internet.wifi_signal_db}

  - platform: copy # Reports the WiFi signal strength in %
    source_id: wifi_signal_db
    name: "WiFi Signal Percent"
    id: wifi_signal_percent
    icon: "mdi:wifi-arrow-up-down"
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: "Signal %"
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_network_and_internet
      sorting_weight: ${sorting_groups.network_and_internet.wifi_signal_percent}

  - platform: template
    name: "GNSS Reception Quality"
    id: gnss_reception_quality
    icon: "mdi:satellite-variant"
    update_interval: 30s
    unit_of_measurement: "Q"
    accuracy_decimals: 0
    web_server:
      sorting_group_id: sorting_group_gnss_sensor_status
      sorting_weight: ${sorting_groups.gnss_sensor_status.gnss_reception_quality}
    lambda: |-
      if (isnan(id(gnss_hdop).state) || isnan(id(gnss_satelites).state)) 
      {
        return NAN;
      }
      
      const float hdop = id(gnss_hdop).state;
      const int sats = (int) id(gnss_satelites).state;

      if (sats < 4) 
      {
        return 0.0; // Poor reception
      } else if (hdop < 1.0) 
      {
        return 3.0; // Excellent
      } else if (hdop < 2.0) 
      {
        return 2.0; // Good
      } else if (hdop < 5.0) 
      {
        return 1.0; // Fair
      } else 
      {
        return 0.0; // Poor
      }

  - platform: bno085_rvc
    id: panel_imu
    uart_id: bno085_uart
    update_interval: 10ms

    pitch:
      name: "IMU Pitch (Tilt Nose down/Nose up)"
      id: panel_imu_pitch
      unit_of_measurement: "°"
      accuracy_decimals: 1
      icon: "mdi:arrow-decision-auto"
      filters:
        - sliding_window_moving_average:
            send_first_at: 10
            window_size: 50
            send_every: 10
      web_server:
        sorting_group_id: sorting_group_imu_sensor_status
        sorting_weight: ${sorting_groups.imu_sensor_status.panel_imu_pitch}

    roll:
      name: "IMU Roll (Tilt Left/Right)"
      id: panel_imu_roll
      unit_of_measurement: "°"
      accuracy_decimals: 1
      icon: "mdi:rotate-orbit"
      filters:
        - sliding_window_moving_average:
            send_first_at: 10
            window_size: 50
            send_every: 10
      web_server:
        sorting_group_id: sorting_group_imu_sensor_status
        sorting_weight: ${sorting_groups.imu_sensor_status.panel_imu_roll}

    yaw:
      name: "IMU Compass Heading"
      id: panel_imu_yaw
      unit_of_measurement: "°"
      accuracy_decimals: 1
      icon: "mdi:compass"
      filters:
        - sliding_window_moving_average:
            send_first_at: 10
            window_size: 50
            send_every: 10
      web_server:
        sorting_group_id: sorting_group_imu_sensor_status
        sorting_weight: ${sorting_groups.imu_sensor_status.panel_imu_yaw}
    x_accel:
      name: "IMU X Accel"
      id: accel_panel_x
      disabled_by_default: true
      filters:
        - sliding_window_moving_average:
            send_first_at: 10
            window_size: 50
            send_every: 10
      web_server:
        sorting_group_id: sorting_group_imu_sensor_status
        sorting_weight: ${sorting_groups.imu_sensor_status.accel_panel_x}
    y_accel:
      name: "IMU Y Accel"
      id: accel_panel_y
      disabled_by_default: true
      filters:
        - sliding_window_moving_average:
            send_first_at: 10
            window_size: 50
            send_every: 10
      web_server:
        sorting_group_id: sorting_group_imu_sensor_status
        sorting_weight: ${sorting_groups.imu_sensor_status.accel_panel_y}
    z_accel:
      name: "IMU Z Accel"
      id: accel_panel_z
      disabled_by_default: true
      filters:
        - sliding_window_moving_average:
            send_first_at: 10
            window_size: 50
            send_every: 10
      web_server:
        sorting_group_id: sorting_group_imu_sensor_status
        sorting_weight: ${sorting_groups.imu_sensor_status.accel_panel_z}

  - platform: template
    name: "Panel Pitch (Tilt Nose down/Nose up)"
    id: panel_pitch
    icon: "mdi:incline"
    unit_of_measurement: "°"
    accuracy_decimals: 1
    update_interval: 500ms
    web_server:
      sorting_group_id: sorting_group_imu_sensor_status
      sorting_weight: ${sorting_groups.imu_sensor_status.panel_pitch}
    lambda: |-
      return id(invert_panel_pitch_angle_switch).state ? -id(panel_imu_pitch).state : id(panel_imu_pitch).state;

  - platform: template
    name: "Panel elevation angle"
    id: panel_elevation_angle_sensor
    unit_of_measurement: "°"
    icon: "mdi:angle-acute"
    accuracy_decimals: 1
    update_interval: 1s
    lambda: |-
        return id(panel_pitch).state; 
    web_server:
      sorting_group_id: sorting_group_elevation_axis
      sorting_weight: ${sorting_groups.elevation_axis.panel_elevation_angle_sensor}

  - platform: ina219
    address: ${i2c_address.ina219_elevation_motor}
    shunt_resistance: 0.1 ohm
    id: motor_elevation_electrical_sensor
    current:
      name: "Elevation Motor supply current"
      id: motor_elevation_supply_current
      icon: "mdi:current-ac"
      disabled_by_default: false
      accuracy_decimals: 3
      web_server:
        sorting_group_id: sorting_group_elevation_motor_status
        sorting_weight: ${sorting_groups.motor_status.motor_elevation_supply_current}     
    power:
      name: "Elevation Motor supply Power"
      id: motor_elevation_supply_power
      icon: "mdi:flash"
      disabled_by_default: true
      accuracy_decimals: 2
      web_server:
        sorting_group_id: sorting_group_elevation_motor_status
        sorting_weight: ${sorting_groups.motor_status.motor_elevation_supply_power}     
    bus_voltage: 
      name: "Elevation Motor supply voltage"
      id: motor_elevation_supply_voltage
      icon: "mdi:sine-wave"
      disabled_by_default: false
      accuracy_decimals: 2
      web_server:
        sorting_group_id: sorting_group_elevation_motor_status
        sorting_weight: ${sorting_groups.motor_status.motor_elevation_supply_voltage} 
    shunt_voltage:
      name: "Elevation Motor supply Shunt Voltage"
      id: motor_elevation_shunt_voltage
      icon: "mdi:sine-wave"
      disabled_by_default: true
      accuracy_decimals: 4
      web_server:
        sorting_group_id: sorting_group_elevation_motor_status
        sorting_weight: ${sorting_groups.motor_status.motor_elevation_shunt_voltage}   
    max_voltage: 15.0V
    max_current: 3.0A
    update_interval: 250ms

  - platform: ina219
    address: ${i2c_address.ina219_azimuth_motor}
    shunt_resistance: 0.1 ohm
    id: motor_azimuth_electrical_sensor
    current:
      name: "Azimuth Motor supply current"
      id: motor_azimuth_supply_current
      icon: "mdi:current-ac"
      disabled_by_default: false
      accuracy_decimals: 3
      web_server:
        sorting_group_id: sorting_group_azimuth_motor_status
        sorting_weight: ${sorting_groups.motor_status.motor_azimuth_supply_current}        
    power:
      name: "Azimuth Motor supply Power"
      id: motor_azimuth_supply_power
      icon: "mdi:flash"
      disabled_by_default: true
      accuracy_decimals: 2
      web_server:
        sorting_group_id: sorting_group_azimuth_motor_status
        sorting_weight: ${sorting_groups.motor_status.motor_azimuth_supply_power}
    bus_voltage: 
      name: "Azimuth Motor supply voltage"
      id: motor_azimuth_supply_voltage
      icon: "mdi:sine-wave"
      disabled_by_default: false
      accuracy_decimals: 2
      web_server:
        sorting_group_id: sorting_group_azimuth_motor_status
        sorting_weight: ${sorting_groups.motor_status.motor_azimuth_supply_voltage}
    shunt_voltage:
      name: "Azimuth Motor supply Shunt Voltage"
      id: motor_azimuth_shunt_voltage
      icon: "mdi:sine-wave"
      disabled_by_default: true
      accuracy_decimals: 4
      web_server:
        sorting_group_id: sorting_group_azimuth_motor_status
        sorting_weight: ${sorting_groups.motor_status.motor_azimuth_shunt_voltage}
    max_voltage: 15.0V
    max_current: 3.0A
    update_interval: 250ms

  - platform: template
    name: "Panel Heading"
    id: panel_compass_heading
    icon: "mdi:angle-acute"
    unit_of_measurement: "°"
    accuracy_decimals: 1
    update_interval: 500ms
    disabled_by_default: false
    web_server:
      sorting_group_id: sorting_group_azimuth_axis
      sorting_weight: 4
    lambda: |-
      if (!isnan(id(panel_imu_yaw).state)) 
      {
        float yaw = id(panel_imu_yaw).state + id(magnetic_declination).state; 

        if (!id(invert_panel_pitch_angle_switch).state)
        {
          yaw = yaw + ${compass_to_panel_heading_inversion_degree};
        }

        return (yaw < 0) ? yaw + 360.0 : yaw;
      } else 
      {
        return NAN;
      }

    on_value:
      then:
        lambda: |-
          if (id(auto_set_compass_heading_to_device_azimuth_orientation).state)
          {
            float precision = 1.0;  // multiplier to round to defined precision
            float angle = floor(x / precision + 0.5) * precision;
            auto call = id(panel_azimuth_orientation).make_call();
            call.set_value(angle);
            call.perform();
          }

### Weather settings below this line

  - platform: template
    name: "OWM Wind speed current"
    id: wind_speed_current
    icon: "mdi:weather-windy"
    unit_of_measurement: "m/s"
    accuracy_decimals: 1
    update_interval: 1s
    web_server:
      sorting_group_id: sorting_group_weather_settings
      sorting_weight: ${sorting_groups.weather_settings.wind_speed_current}
    lambda: |-
      if (abs(id(global_owm_wind_speed_current) - float(${initial_value.number})) < 0.001
        or !id(global_owm_api_key_valid)
        or id(owm_data_is_expired).state) 
      {
        return NAN;
      } else
      {
        return id(global_owm_wind_speed_current);
      } 

  - platform: template
    name: "OWM Wind gusts current"
    id: wind_gusts_current
    icon: "mdi:wind-power"
    unit_of_measurement: "m/s"
    accuracy_decimals: 1
    update_interval: 1s
    web_server:
      sorting_group_id: sorting_group_weather_settings
      sorting_weight: ${sorting_groups.weather_settings.wind_gusts_current}
    lambda: |-
      if (abs(id(global_owm_wind_gusts_current) - float(${initial_value.number})) < 0.001
        or !id(global_owm_api_key_valid)
        or id(owm_data_is_expired).state) 
      {
        return NAN;
      } else
      {
        return id(global_owm_wind_gusts_current);
      }

  - platform: template
    name: "OWM Cloud coverage current"
    id: cloud_coverage_current
    icon: "mdi:cloud-percent"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    update_interval: 1s
    web_server:
      sorting_group_id: sorting_group_weather_settings
      sorting_weight: ${sorting_groups.weather_settings.cloud_coverage_current}
    lambda: |-
      if (abs(id(global_owm_cloud_coverage_current) - float(${initial_value.number})) < 0.001
        or !id(global_owm_api_key_valid)
        or id(owm_data_is_expired).state)  
      {
        return NAN;
      } else
      {
        return id(global_owm_cloud_coverage_current);
      }
    on_value: 
      then:
        - script.execute: perform_automatic_cloudy_mode_control_estimation

  - platform: template
    name: "OWM Wind speed +1hr"
    id: wind_speed_in_one_hour
    icon: "mdi:weather-windy"
    unit_of_measurement: "m/s"
    accuracy_decimals: 1
    update_interval: 1s
    web_server:
      sorting_group_id: sorting_group_weather_settings
      sorting_weight: ${sorting_groups.weather_settings.wind_speed_in_one_hour}
    lambda: |-
      if (abs(id(global_owm_wind_speed_in_one_hour) - float(${initial_value.number})) < 0.001
        or !id(global_owm_api_key_valid)
        or id(owm_data_is_expired).state)  
      {
        return NAN;
      } else
      {
        return id(global_owm_wind_speed_in_one_hour);
      }

  - platform: template
    name: "OWM Wind gusts +1hr"
    id: wind_gusts_in_one_hour
    icon: "mdi:wind-power"
    unit_of_measurement: "m/s"
    accuracy_decimals: 1
    update_interval: 1s
    web_server:
      sorting_group_id: sorting_group_weather_settings
      sorting_weight: ${sorting_groups.weather_settings.wind_gusts_in_one_hour}
    lambda: |-
      if (abs(id(global_owm_wind_gusts_in_one_hour) - float(${initial_value.number})) < 0.001
        or !id(global_owm_api_key_valid)
        or id(owm_data_is_expired).state)  
      {
        return NAN;
      } else
      {
        return id(global_owm_wind_gusts_in_one_hour);
      }

  - platform: template
    name: "OWM Cloud coverage +1hr"
    id: cloud_coverage_in_one_hour
    icon: "mdi:cloud-percent"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    update_interval: 1s
    web_server:
      sorting_group_id: sorting_group_weather_settings
      sorting_weight: ${sorting_groups.weather_settings.cloud_coverage_in_one_hour}
    lambda: |-
      if (abs(id(global_owm_cloud_coverage_in_one_hour) - float(${initial_value.number})) < 0.001
        or !id(global_owm_api_key_valid)
        or id(owm_data_is_expired).state)  
      {
        return NAN;
      } else
      {
        return id(global_owm_cloud_coverage_in_one_hour);
      }



output:

  - platform: gpio
    pin: ${gpio.mcu_led_out}
    id: mcu_led_output_id

binary_sensor:

  # Fault detection status sensors

  - platform: template
    name: "Azimuth axis not calibrated"
    id: azimuth_axis_not_calibrated
    icon: "mdi:alert-outline"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.azimuth_axis_not_calibrated}
    lambda: |-
      return id(azimuth_angle_max_min_not_estimated).state or !id(magnetic_calibration_executed_today).state or id(azimuth_angle_boundaries_measurement_active).state or id(magnetic_declination_calibration_active).state;
    on_state: 
      then:
        - script.execute: perform_publish_states_to_status_text_sensors

  - platform: template
    name: "Elevation axis not calibrated"
    id: elevation_axis_not_calibrated
    icon: "mdi:alert-outline"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.elevation_axis_not_calibrated}
    lambda: |-
      return id(elevation_angle_max_min_not_estimated).state or id(elev_angle_boundaries_measurement_active).state;
    on_state: 
      then:
        - script.execute: perform_publish_states_to_status_text_sensors

  - platform: template
    name: "Azimuth motor blocked (high current)"
    id: azimuth_motor_blocked_current
    icon: "mdi:alert-circle-outline"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.azimuth_motor_blocked_current}
    lambda: |-
      return id(global_azimuth_motor_blocked_high_current_fault_detected);
    on_state: 
      then:
        - script.execute: perform_publish_states_to_status_text_sensors

  - platform: template
    name: "Azimuth motor not connected (low current)"
    id: azimuth_motor_not_connected_low_current
    icon: "mdi:alert-circle-outline"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.azimuth_motor_not_connected_low_current}
    lambda: |-
      return id(global_azimuth_motor_not_connected_fault_detected);
    on_state: 
      then:
        - script.execute: perform_publish_states_to_status_text_sensors

  - platform: template
    name: "Azimuth motor no angle change (CW)"
    id: azimuth_motor_no_angle_change_cw
    icon: "mdi:alert-circle-outline"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.azimuth_motor_no_angle_change_cw}
    lambda: |-
      return id(global_azimuth_motor_blocked_missing_angle_change_cw_fault_detected);
    on_state: 
      then:
        - script.execute: perform_publish_states_to_status_text_sensors

  - platform: template
    name: "Azimuth motor no angle change (CCW)"
    id: azimuth_motor_no_angle_change_ccw
    icon: "mdi:alert-circle-outline"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.azimuth_motor_no_angle_change_ccw}
    lambda: |-
      return id(global_azimuth_motor_blocked_missing_angle_change_ccw_fault_detected);
    on_state: 
      then:
        - script.execute: perform_publish_states_to_status_text_sensors

  - platform: template
    name: "Elevation motor blocked (high current)"
    id: elevation_motor_blocked_current
    icon: "mdi:alert-circle-outline"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.elevation_motor_blocked_current}
    lambda: |-
      return id(global_elevation_motor_blocked_high_current_fault_detected);
    on_state: 
      then:
        - script.execute: perform_publish_states_to_status_text_sensors

  - platform: template
    name: "Elevation motor not connected (low current)"
    id: elevation_motor_not_connected_low_current
    icon: "mdi:alert-circle-outline"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.elevation_motor_not_connected_low_current}
    lambda: |-
      return id(global_elevation_motor_not_connected_fault_detected);
    on_state: 
      then:
        - script.execute: perform_publish_states_to_status_text_sensors

  - platform: template
    name: "Elevation motor no angle change (lift)"
    id: elevation_motor_no_angle_change_lift
    icon: "mdi:alert-circle-outline"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.elevation_motor_no_angle_change_lift}
    lambda: |-
      return id(global_elevation_motor_blocked_missing_angle_change_while_lift_fault_detected);
    on_state: 
      then:
        - script.execute: perform_publish_states_to_status_text_sensors

  - platform: template
    name: "Elevation motor no angle change (lowering)"
    id: elevation_motor_no_angle_change_lowering
    icon: "mdi:alert-circle-outline"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.elevation_motor_no_angle_change_lowering}
    lambda: |-
      return id(global_elevation_motor_blocked_missing_angle_change_while_lowering_fault_detected);
    on_state: 
      then:
        - script.execute: perform_publish_states_to_status_text_sensors

  - platform: template
    name: "Magnetic declination calibration failed"
    id: magnetic_declination_calibration_fault_detected
    icon: "mdi:alert-circle-outline"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.magnetic_declination_calibration_fault_detected}
    lambda: |-
      return id(global_magnetic_declination_calibration_fault_detected);
    on_state: 
      then:
        - script.execute: perform_publish_states_to_status_text_sensors

  - platform: template
    name: "Azimuth angle calculation failed"
    id: azimuth_angle_calculation_fault_detected
    icon: "mdi:alert-circle-outline"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.azimuth_angle_calculation_fault_detected}
    lambda: |-
      return id(global_azimuth_angle_calculation_fault_detected);
    on_state: 
      then:
        - script.execute: perform_publish_states_to_status_text_sensors

  - platform: template
    name: "Elevation angle calculation failed"
    id: elevation_angle_calculation_fault_detected
    icon: "mdi:alert-circle-outline"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.elevation_angle_calculation_fault_detected}
    lambda: |-
      return id(global_elevation_angle_calculation_fault_detected);
    on_state: 
      then:
        - script.execute: perform_publish_states_to_status_text_sensors

  - platform: template
    name: "Elevation motor wrong direction detected"
    id: elevation_motor_wrong_direction_detected_binary_sensor
    icon: "mdi:alert-circle-outline"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.elevation_motor_blocked_current}
    lambda: |-
      return id(global_elevation_motor_wrong_direction_detected);
    on_state: 
      then:
        - script.execute: perform_publish_states_to_status_text_sensors

  - platform: template
    name: "Azimuth motor wrong direction detected"
    id: azimuth_motor_wrong_direction_detected_binary_sensor
    icon: "mdi:alert-circle-outline"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.azimuth_motor_blocked_current}
    lambda: |-
      return id(global_azimuth_motor_wrong_direction_detected);
    on_state: 
      then:
        - script.execute: perform_publish_states_to_status_text_sensors

  - platform: template
    name: "Elevation target angle timeout detected"
    id: elevation_target_angle_timeout_detected_binary_sensor
    icon: "mdi:alert-circle-outline"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.elevation_motor_blocked_current}
    lambda: |-
      return id(global_elevation_target_angle_timeout_detected);
    on_state: 
      then:
        - script.execute: perform_publish_states_to_status_text_sensors

  - platform: template
    name: "Azimuth target angle timeout detected"
    id: azimuth_target_angle_timeout_detected_binary_sensor
    icon: "mdi:alert-circle-outline"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.azimuth_motor_blocked_current}
    lambda: |-
      return id(global_azimuth_target_angle_timeout_detected);
    on_state: 
      then:
        - script.execute: perform_publish_states_to_status_text_sensors



        

  # Measurement and calibrations status sensors

  - platform: template
    name: "Measurement or calibration active"
    id: measurement_or_calibration_active
    icon: "mdi:progress-clock"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.measurement_or_calibration_active}
    lambda: |-
      return id(elev_angle_boundaries_measurement_active).state or id(azimuth_angle_boundaries_measurement_active).state or id(magnetic_declination_calibration_active).state;

  - platform: template
    name: "Elevation angle boundaries measurement active"
    id: elev_angle_boundaries_measurement_active
    icon: "mdi:progress-clock"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.elev_angle_boundaries_measurement_active}
    lambda: |-
      return id(global_perform_automatic_elev_angle_boundaries_measurement_running);

  - platform: template
    name: "Azimuth angle boundaries measurement active"
    id: azimuth_angle_boundaries_measurement_active
    icon: "mdi:progress-clock"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.azimuth_angle_boundaries_measurement_active}
    lambda: |-
      return id(global_perform_automatic_azimuth_angle_boundaries_measurement_running);

  - platform: template
    name: "Magnetic declination calibration active"
    id: magnetic_declination_calibration_active
    icon: "mdi:progress-clock"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.magnetic_declination_calibration_active}
    lambda: |-
      return id(global_magnetic_declination_calibration_running);

 # Axis control mode status sensors

  - platform: template
    name: "Elevation axis mode active"
    id: elevation_axis_mode_activated
    icon: "mdi:axis-arrow"
    web_server:
      sorting_group_id: sorting_group_elevation_axis
      sorting_weight: ${sorting_groups.elevation_axis.elevation_axis_mode_activated}
    lambda: |-
      return id(axis_control_mode).active_index() == 0;

  - platform: template
    name: "Elevation & Azimuth axis mode active"
    id: elevation_and_azimuth_axis_mode_activated
    icon: "mdi:axis-arrow"
    web_server:
      sorting_group_id: sorting_group_elevation_axis
      sorting_weight: ${sorting_groups.elevation_axis.elevation_axis_mode_activated}
    lambda: |-
      return id(axis_control_mode).active_index() == 1;

# Calibration status

  - platform: template
    name: "Magnetic calibration executed today"
    id: magnetic_calibration_executed_today
    icon: "mdi:check-circle"
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_imu_sensor_status
      sorting_weight: ${sorting_groups.imu_sensor_status.imu_sensor_ready}
    lambda: |-
      if (id(global_last_magnetic_calibration_success) == 0) 
      {
        return false;
      }

      time_t now = id(ds3231_time).now().timestamp;
      struct tm t_now;
      t_now = *localtime(&now);

      time_t ts_last_calibration = id(global_last_magnetic_calibration_success);
      struct tm t_calibrated;
      t_calibrated = *localtime(&ts_last_calibration);

      return (t_now.tm_year == t_calibrated.tm_year 
              && t_now.tm_mon  == t_calibrated.tm_mon 
              && t_now.tm_mday == t_calibrated.tm_mday);


  - platform: template
    name: "Elevation angle max|min not estimated"
    id: elevation_angle_max_min_not_estimated
    icon: "mdi:alert-circle"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.elevation_angle_max_min_not_estimated}
    lambda: |-
      return !(abs(id(panel_elevation_angle_max).state - float(${initial_value.panel_elev_angle_max})) > 0.001) and !(abs(id(panel_elevation_angle_min).state - float(${initial_value.panel_elev_angle_min})) > 0.001);
    on_state: 
      then:
        - script.execute: perform_publish_states_to_status_text_sensors

  - platform: template
    name: "Azimuth angle max|min not estimated"
    id: azimuth_angle_max_min_not_estimated
    icon: "mdi:alert-circle"
    web_server:
      sorting_group_id: sorting_group_fault_and_measurements_detection
      sorting_weight: ${sorting_groups.fault_and_measurements_detection.azimuth_angle_max_min_not_estimated}
    lambda: |-
      return !(abs(id(panel_azimuth_angle_max).state - float(${initial_value.panel_azimuth_angle_max})) > 0.001) and !(abs(id(panel_azimuth_angle_min).state - float(${initial_value.panel_azimuth_angle_min})) > 0.001);
    on_state: 
      then:
        - script.execute: perform_publish_states_to_status_text_sensors

# Sensor status

  - platform: template
    name: "Elevation Motor Sensor Status"
    id: elevation_motor_sensor_ready
    icon: "mdi:check-circle-outline"
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_elevation_motor_status
      sorting_weight: ${sorting_groups.motor_status.elevation_motor_sensor_ready}
    lambda: |-
      return !isnan(id(motor_elevation_supply_current).state);

  - platform: template
    name: "Azimuth Motor Sensor Status"
    id: azimuth_motor_sensor_ready
    icon: "mdi:check-circle-outline"
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_azimuth_motor_status
      sorting_weight: ${sorting_groups.motor_status.azimuth_motor_sensor_ready}
    lambda: |-
      return !isnan(id(motor_azimuth_supply_current).state);

  - platform: template
    name: "GNSS Sensor Status"
    id: gnss_sensor_ready
    icon: "mdi:satellite-variant"
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_gnss_sensor_status
      sorting_weight: ${sorting_groups.gnss_sensor_status.gnss_sensor_ready}
    lambda: |-
      return !isnan(id(gnss_reception_quality).state);
      
  - platform: template
    name: "DS3231 Sensor Status"
    id: ds3231_sensor_ready
    icon: "mdi:clock-check"
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_time_sensor_status
      sorting_weight: ${sorting_groups.time_sensor_status.ds3231_sensor_ready}
    lambda: |-
      return !isnan(id(ds3231_temperature_sensor).state);
    on_press:
      - lambda: |-
          ESP_LOGE("DS3231", "DS3231 data is now available."); 
      - script.execute: perform_inital_angle_state_initialization 
      - script.execute: check_if_magnetic_declination_calibration_is_needed    # in case there was no magnetic declination calibration today it will be executed now
      - script.wait: check_if_magnetic_declination_calibration_is_needed
      
  - platform: template
    name: "IMU Sensor Status"
    id: imu_sensor_ready
    icon: "mdi:check-circle-outline"
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_imu_sensor_status
      sorting_weight: ${sorting_groups.imu_sensor_status.imu_sensor_ready}
    lambda: |-
      return !isnan(id(accel_panel_x).state);

# MISC Sensors

  - platform: template
    name: "WiFi connected"
    id: wifi_connected_binary_sensor
    icon: "mdi:wifi-check"
    web_server:
      sorting_group_id: sorting_group_network_and_internet
      sorting_weight: ${sorting_groups.network_and_internet.wifi_connected_binary_sensor}
    lambda: |-
      return id(wifi_pyh_id).is_connected();

  - platform: template
    name: "Internet connection available"
    id: internet_connection_available
    icon: "mdi:lan-check"
    entity_category: "diagnostic"
    device_class: "connectivity"
    web_server:
      sorting_group_id: sorting_group_network_and_internet
      sorting_weight: ${sorting_groups.network_and_internet.internet_connection_available}
    lambda: |-
      return id(global_internet_connection_test_success);
    on_state: 
      then:
        - script.execute: perform_publish_states_to_status_text_sensors

  - platform: template
    name: "OWM API Key entered"
    id: owm_api_key_entered
    icon: "mdi:check-circle"
    entity_category: "diagnostic"
    device_class: "connectivity"
    web_server:
      sorting_group_id: sorting_group_weather_settings
      sorting_weight: ${sorting_groups.weather_settings.owm_api_key_entered}
    lambda: |-
      return id(owm_api_key).state != "${initial_value.initial_owm_key_value}";
    on_state: 
      then:
        - script.execute: perform_publish_states_to_status_text_sensors
        - switch.turn_off: auto_owm_data_retrieval

  - platform: template
    name: "OWM API Key validated"
    id: owm_api_key_valid
    icon: "mdi:check-circle"
    entity_category: "diagnostic"
    device_class: "connectivity"
    web_server:
      sorting_group_id: sorting_group_weather_settings
      sorting_weight: ${sorting_groups.weather_settings.owm_api_key_valid}
    lambda: |-
      return id(global_owm_api_key_valid);
    on_state: 
      then:
        - script.execute: perform_publish_states_to_status_text_sensors
        - switch.turn_off: auto_owm_data_retrieval

  - platform: template
    name: "GNSS position valid"
    id: gnss_position_valid
    icon: "mdi:map-check"
    disabled_by_default: true
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_gnss_sensor_status
      sorting_weight: ${sorting_groups.gnss_sensor_status.gnss_position_valid}
    lambda: |-
      return (id(gnss_satelites).state >= ${gnss_min_required_sat_count} and id(gnss_hdop).state <= ${gnss_min_required_gnss_hdop});

  - platform: template
    name: "Sun elevation angle below stand by mode threshold"
    id: sun_elevation_angle_below_stand_by_mode_threshold
    icon: "mdi:weather-sunset-down"
    disabled_by_default: true
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_standby_mode
      sorting_weight: ${sorting_groups.standby_mode.sun_elevation_angle_below_stand_by_mode_threshold}
    lambda: |-
      return id(sun_elevation).state <= id(stand_by_mode_elevation_trigger_angle).state;

# OWM data

  - platform: template
    name: "OWM Cloud coverage above threshold"
    id: owm_cloud_coverage_above_threshold
    icon: "mdi:cloud"
    disabled_by_default: true
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_weather_settings
      sorting_weight: ${sorting_groups.weather_settings.owm_cloud_coverage_above_threshold}
    lambda: |-
      // Hysteresis logic: activate at threshold, deactivate at lower threshold
      if (!isnan(id(cloud_coverage_current).state))
      {
        if (!id(global_cloudy_mode_hysteresis_active) && id(cloud_coverage_current).state >= ${weather_hysteresis.cloudy_mode_activation_threshold})
        {
          id(global_cloudy_mode_hysteresis_active) = true;
          return true;
        }
        else if (id(global_cloudy_mode_hysteresis_active) && id(cloud_coverage_current).state < ${weather_hysteresis.cloudy_mode_deactivation_threshold})
        {
          id(global_cloudy_mode_hysteresis_active) = false;
          return false;
        }
        return id(global_cloudy_mode_hysteresis_active);
      }
      return false;

  - platform: template
    name: "OWM Wind speed above threshold"
    id: owm_wind_speed_above_threshold
    icon: "mdi:wind-power-outline"
    disabled_by_default: false
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_weather_settings
      sorting_weight: ${sorting_groups.weather_settings.owm_wind_speed_above_threshold}
    lambda: |-
      // Hysteresis logic: activate at threshold, deactivate at lower threshold
      if (!isnan(id(wind_speed_current).state))
      {
        if (!id(global_wind_speed_hysteresis_active) && id(wind_speed_current).state >= ${weather_hysteresis.wind_speed_activation_threshold})
        {
          id(global_wind_speed_hysteresis_active) = true;
          return true;
        }
        else if (id(global_wind_speed_hysteresis_active) && id(wind_speed_current).state < ${weather_hysteresis.wind_speed_deactivation_threshold})
        {
          id(global_wind_speed_hysteresis_active) = false;
          return false;
        }
        return id(global_wind_speed_hysteresis_active);
      }
      return false;

  - platform: template
    name: "OWM Wind gusts above threshold"
    id: owm_wind_gusts_above_threshold
    icon: "mdi:wind-power"
    disabled_by_default: false
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_weather_settings
      sorting_weight: ${sorting_groups.weather_settings.owm_wind_gusts_above_threshold}
    lambda: |-
      // Hysteresis logic: activate at threshold, deactivate at lower threshold
      if (!isnan(id(wind_gusts_current).state))
      {
        if (!id(global_wind_gusts_hysteresis_active) && id(wind_gusts_current).state >= ${weather_hysteresis.wind_gusts_activation_threshold})
        {
          id(global_wind_gusts_hysteresis_active) = true;
          return true;
        }
        else if (id(global_wind_gusts_hysteresis_active) && id(wind_gusts_current).state < ${weather_hysteresis.wind_gusts_deactivation_threshold})
        {
          id(global_wind_gusts_hysteresis_active) = false;
          return false;
        }
        return id(global_wind_gusts_hysteresis_active);
      }
      return false;

  - platform: template
    name: "OWM data is old"
    id: owm_data_is_old
    icon: "mdi:clock-alert"
    disabled_by_default: true
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_weather_settings
      sorting_weight: ${sorting_groups.weather_settings.owm_data_is_old}
    lambda: |-
      return ((id(global_owm_last_data_retrieval_success) + ${owm_data_expiration_time} ) <= id(ds3231_time).now().timestamp);

  - platform: template
    name: "OWM data is expired"
    id: owm_data_is_expired
    icon: "mdi:clock-remove"
    disabled_by_default: true
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_weather_settings
      sorting_weight: ${sorting_groups.weather_settings.owm_data_is_expired}
    lambda: |-
      return ((id(global_owm_last_data_retrieval_success) + ${owm_data_expiration_shutdown_time} ) <= id(ds3231_time).now().timestamp);

### Elevation Motor sensors

  - platform: template
    name: "Elevation Motor is in blocked state"
    id: elevation_motor_is_blocked_binary_sensor
    icon: "mdi:pause-circle"
    disabled_by_default: true
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_elevation_motor_status
      sorting_weight: ${sorting_groups.motor_status.elevation_motor_is_blocked_binary_sensor}
    lambda: |-
      return (id(motor_elevation_supply_current).state >= id(elevation_motor_blocked_current_threshold).state);

  - platform: template
    name: "Elevation Motor voltage is valid"
    id: elevation_motor_voltage_is_valid
    icon: "mdi:check-circle-outline"
    disabled_by_default: true
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_elevation_motor_status
      sorting_weight: ${sorting_groups.motor_status.elevation_motor_voltage_is_valid}
    lambda: |-
      return (id(motor_elevation_supply_voltage).state >= (${motor_elevation_nominal_supply_voltage} - ${motor_elevation_supply_voltage_tolerance}) and id(motor_elevation_supply_voltage).state <= (${motor_elevation_nominal_supply_voltage} + ${motor_elevation_supply_voltage_tolerance}));

  - platform: template
    name: "Elevation Motor is in running state"
    id: elevation_motor_is_running_binary_sensor
    icon: "mdi:play-circle"
    disabled_by_default: true
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_elevation_motor_status
      sorting_weight: ${sorting_groups.motor_status.elevation_motor_is_running_binary_sensor}
    lambda: |-
      return (id(motor_elevation_supply_current).state >= ${motor_elevation_min_current_active});

  - platform: template
    name: "Elevation Motor is in idle state"
    id: elevation_motor_is_idle
    icon: "mdi:sleep"
    disabled_by_default: true
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_elevation_motor_status
      sorting_weight: ${sorting_groups.motor_status.elevation_motor_is_idle}
    lambda: |-
      return (id(motor_elevation_supply_current).state <= ${motor_elevation_max_current_at_idle});

### Stand by mode triggers

  - platform: template
    name: "Standby mode trigger Sun elevation"
    id: stand_by_mode_trigger_sun_elevation
    icon: "mdi:sleep"
    web_server:
      sorting_group_id: sorting_group_standby_mode
      sorting_weight: ${sorting_groups.standby_mode.stand_by_mode_trigger_sun_elevation}
    lambda: |-
      return id(sun_elevation_angle_below_stand_by_mode_threshold).state;

  - platform: template
    name: "Standby mode trigger expired OWM data"
    id: stand_by_mode_trigger_expired_owm_data
    icon: "mdi:sleep"
    web_server:
      sorting_group_id: sorting_group_standby_mode
      sorting_weight: ${sorting_groups.standby_mode.stand_by_mode_trigger_expired_owm_data}
    lambda: |-
      return id(owm_data_is_expired).state && id(owm_api_key_valid).state;

  - platform: template
    name: "Standby mode trigger high winds"
    id: stand_by_mode_trigger_high_winds
    icon: "mdi:sleep"
    web_server:
      sorting_group_id: sorting_group_standby_mode
      sorting_weight: ${sorting_groups.standby_mode.stand_by_mode_trigger_high_winds}
    lambda: |-
      return (id(owm_wind_gusts_above_threshold).state || id(owm_wind_speed_above_threshold).state) && !id(owm_data_is_expired).state && id(owm_api_key_valid).state;


### Elevation movement sensors

  - platform: template
    name: "Panel is in stand by Position"
    id: panel_is_in_stand_by_position
    icon: "mdi:sleep"
    web_server:
      sorting_group_id: sorting_group_standby_mode
      sorting_weight: ${sorting_groups.standby_mode.panel_is_in_stand_by_position}
    lambda: |-
      return (abs(id(stand_by_mode_elevation_target_angle).state - id(panel_elevation_angle_sensor).state) <= id(panel_elev_target_angle_tolerance).state) 
        && (abs(id(stand_by_mode_azimuth_target_angle).state - id(panel_compass_heading).state) <= id(panel_azimuth_target_angle_tolerance).state);

  - platform: template
    name: "Panel lifting planned"
    id: panel_lifting_planned
    icon: "mdi:arrow-up-box"
    disabled_by_default: false
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_elevation_axis
      sorting_weight: ${sorting_groups.elevation_axis.panel_lifting_planned}
    lambda: |-
      if (id(elevation_motor_direction_inverted).state)
        return !id(motor_elevation_plus_pin).state and id(motor_elevation_minus_pin).state;
      else
        return id(motor_elevation_plus_pin).state and !id(motor_elevation_minus_pin).state;

  - platform: template
    name: "Panel lowering planned"
    id: panel_lowering_planned
    icon: "mdi:arrow-down-box"
    disabled_by_default: false
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_elevation_axis
      sorting_weight: ${sorting_groups.elevation_axis.panel_lowering_planned}
    lambda: |-
      if (id(elevation_motor_direction_inverted).state)
        return id(motor_elevation_plus_pin).state and !id(motor_elevation_minus_pin).state;
      else
        return !id(motor_elevation_plus_pin).state and id(motor_elevation_minus_pin).state;

  - platform: template
    name: "Panel lifting active"
    id: panel_lifting_active
    icon: "mdi:arrow-up"
    disabled_by_default: false
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_elevation_axis
      sorting_weight: ${sorting_groups.elevation_axis.panel_lifting_active}
    lambda: |-
      return id(panel_lifting_planned).state and id(elevation_motor_is_running_binary_sensor).state;

  - platform: template
    name: "Panel lowering active"
    id: panel_lowering_active
    icon: "mdi:arrow-down"
    disabled_by_default: false
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_elevation_axis
      sorting_weight: ${sorting_groups.elevation_axis.panel_lowering_active}
    lambda: |-
      return id(panel_lowering_planned).state and id(elevation_motor_is_running_binary_sensor).state;

  - platform: template
    name: "Endstop Top virtual"
    id: top_virtual_endstop_binary_sensor
    icon: "mdi:stop"
    disabled_by_default: false
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_elevation_axis
      sorting_weight: ${sorting_groups.elevation_axis.top_virtual_endstop_binary_sensor}
    lambda: |-
      return (id(panel_elevation_angle_sensor).state >= id(panel_elevation_angle_max).state) or (id(panel_elevation_angle_sensor).state >= (id(panel_elevation_angle_max).state * 0.95) and (!id(elevation_motor_is_running_binary_sensor).state and !id(panel_lifting_active).state and !id(panel_lowering_active).state));                    

  - platform: template
    name: "Endstop bottom virtual"
    id: bottom_virtual_endstop_binary_sensor
    icon: "mdi:stop"
    disabled_by_default: false
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_elevation_axis
      sorting_weight: ${sorting_groups.elevation_axis.bottom_virtual_endstop_binary_sensor}
    lambda: |-
      return (id(panel_elevation_angle_sensor).state <= id(panel_elevation_angle_min).state) or (id(panel_elevation_angle_sensor).state <= (id(panel_elevation_angle_min).state * 1.05) and (!id(elevation_motor_is_running_binary_sensor).state and !id(panel_lifting_active).state and !id(panel_lowering_active).state));

  - platform: template
    name: "Panel lifting to elev target angle needed"
    id: panel_lifting_to_elev_target_angle_needed_binary_sensor
    icon: "mdi:arrow-up-thin"
    disabled_by_default: false
    entity_category: "diagnostic"
    lambda: |-
      return (id(panel_elev_target_angle).state > id(panel_elevation_angle_sensor).state);
    web_server:
      sorting_group_id: sorting_group_elevation_axis
      sorting_weight: ${sorting_groups.elevation_axis.panel_lifting_to_elev_target_angle_needed_binary_sensor}

  - platform: template
    name: "Panel lowering to elev target angle needed"
    id: panel_lowering_to_elev_target_angle_needed_binary_sensor
    icon: "mdi:arrow-down-thin"
    disabled_by_default: false
    entity_category: "diagnostic"
    lambda: |-
      return (id(panel_elev_target_angle).state < id(panel_elevation_angle_sensor).state);
    web_server:
      sorting_group_id: sorting_group_elevation_axis
      sorting_weight: ${sorting_groups.elevation_axis.panel_lowering_to_elev_target_angle_needed_binary_sensor}

  - platform: template
    name: "Panel within elev target angle range"
    id: panel_within_elev_target_angle_range_binary_sensor
    icon: "mdi:check"
    disabled_by_default: false
    entity_category: "diagnostic"
    lambda: |-
      return (abs(id(panel_elev_target_angle).state - id(panel_elevation_angle_sensor).state) <= id(panel_elev_target_angle_tolerance).state);
    on_state:
      - if:
          condition:
            binary_sensor.is_on: panel_within_elev_target_angle_range_binary_sensor
          then:
            - lambda: |-
                id(panel_elevation_target_reached_handled) = false;  // Reset helper variable when target is reached (new movement session)
    web_server:
      sorting_group_id: sorting_group_elevation_axis
      sorting_weight: ${sorting_groups.elevation_axis.panel_within_elev_target_angle_range_binary_sensor}


### Azimuth Motor sensors

  - platform: template
    name: "Azimuth Motor is in blocked state"
    id: azimuth_motor_is_blocked_binary_sensor
    icon: "mdi:pause-circle"
    disabled_by_default: true
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_azimuth_motor_status
      sorting_weight: ${sorting_groups.motor_status.azimuth_motor_is_blocked_binary_sensor}
    lambda: |-
      return (id(motor_azimuth_supply_current).state >= id(azimuth_motor_blocked_current_threshold).state);

  - platform: template
    name: "Azimuth Motor voltage is valid"
    id: azimuth_motor_voltage_is_valid
    icon: "mdi:check-circle-outline"
    disabled_by_default: true
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_azimuth_motor_status
      sorting_weight: ${sorting_groups.motor_status.azimuth_motor_voltage_is_valid}
    lambda: |-
      return (id(motor_azimuth_supply_voltage).state >= (${motor_azimuth_nominal_supply_voltage} - ${motor_azimuth_supply_voltage_tolerance}) and id(motor_azimuth_supply_voltage).state <= (${motor_azimuth_nominal_supply_voltage} + ${motor_azimuth_supply_voltage_tolerance}));

  - platform: template
    name: "Azimuth Motor is in running state"
    id: azimuth_motor_is_running_binary_sensor
    icon: "mdi:play-circle"
    disabled_by_default: true
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_azimuth_motor_status
      sorting_weight: ${sorting_groups.motor_status.azimuth_motor_is_running_binary_sensor}
    lambda: |-
      return (id(motor_azimuth_supply_current).state >= ${motor_azimuth_min_current_active});

  - platform: template
    name: "Azimuth Motor is in idle state"
    id: azimuth_motor_is_idle
    icon: "mdi:pause-circle-outline"
    disabled_by_default: true
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_azimuth_motor_status
      sorting_weight: ${sorting_groups.motor_status.azimuth_motor_is_idle}
    lambda: |-
      return (id(motor_azimuth_supply_current).state <= ${motor_azimuth_max_current_at_idle});

### Azimuth movement sensors
      
  - platform: template
    name: "Panel rotation in CW planned"
    id: panel_rotation_in_cw_planned
    icon: "mdi:rotate-right-variant"
    disabled_by_default: false
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_azimuth_axis
      sorting_weight: ${sorting_groups.azimuth_axis.panel_rotation_in_cw_planned}
    lambda: |-
      if (id(azimuth_motor_direction_inverted).state)
        return !id(motor_azimuth_plus_pin).state and id(motor_azimuth_minus_pin).state;
      else      
        return id(motor_azimuth_plus_pin).state and !id(motor_azimuth_minus_pin).state;

  - platform: template
    name: "Panel rotation in CCW planned"
    id: panel_rotation_in_ccw_planned
    icon: "mdi:rotate-left-variant"
    disabled_by_default: false
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_azimuth_axis
      sorting_weight: ${sorting_groups.azimuth_axis.panel_rotation_in_ccw_planned}
    lambda: |-
      if (id(azimuth_motor_direction_inverted).state)
        return id(motor_azimuth_plus_pin).state and !id(motor_azimuth_minus_pin).state;
      else  
        return !id(motor_azimuth_plus_pin).state and id(motor_azimuth_minus_pin).state;

  - platform: template
    name: "Panel rotation in CW active"
    id: panel_rotation_in_cw_active
    icon: "mdi:rotate-right"
    disabled_by_default: false
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_azimuth_axis
      sorting_weight: ${sorting_groups.azimuth_axis.panel_rotation_in_cw_active}
    lambda: |-
      return id(panel_rotation_in_cw_planned).state and id(azimuth_motor_is_running_binary_sensor).state;

  - platform: template
    name: "Panel rotation in CCW active"
    id: panel_rotation_in_ccw_active
    icon: "mdi:rotate-left"
    disabled_by_default: false
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_azimuth_axis
      sorting_weight: ${sorting_groups.azimuth_axis.panel_rotation_in_ccw_active}
    lambda: |-
      return id(panel_rotation_in_ccw_planned).state and id(azimuth_motor_is_running_binary_sensor).state;

  - platform: template
    name: "Panel left from azimuth target angle"
    id: panel_left_from_azimuth_target_angle_binary_sensor
    icon: "mdi:arrow-left"
    disabled_by_default: false
    entity_category: "diagnostic"
    lambda: |-
      return (id(panel_azimuth_target_angle).state > id(panel_compass_heading).state);
    web_server:
      sorting_group_id: sorting_group_azimuth_axis
      sorting_weight: ${sorting_groups.azimuth_axis.panel_left_from_azimuth_target_angle_binary_sensor}

  - platform: template
    name: "Panel right from azimuth target angle"
    id: panel_right_from_azimuth_target_angle_binary_sensor
    icon: "mdi:arrow-right"
    disabled_by_default: false
    entity_category: "diagnostic"
    lambda: |-
      return (id(panel_azimuth_target_angle).state < id(panel_compass_heading).state);      
    web_server:
      sorting_group_id: sorting_group_azimuth_axis
      sorting_weight: ${sorting_groups.azimuth_axis.panel_right_from_azimuth_target_angle_binary_sensor}

  - platform: template
    name: "Panel within azimuth target angle range"
    id: panel_within_azimuth_target_angle_range_binary_sensor
    icon: "mdi:check"
    disabled_by_default: false
    entity_category: "diagnostic"
    lambda: |-
      return (abs(id(panel_azimuth_target_angle).state - id(panel_compass_heading).state) <= id(panel_azimuth_target_angle_tolerance).state);
    on_state:
      - if:
          condition:
            binary_sensor.is_on: panel_within_azimuth_target_angle_range_binary_sensor
          then:
            - lambda: |-
                id(panel_azimuth_target_reached_handled) = false;  // Reset helper variable when target is reached (new movement session)
    web_server:
      sorting_group_id: sorting_group_azimuth_axis
      sorting_weight: ${sorting_groups.azimuth_axis.panel_within_azimuth_target_angle_range_binary_sensor}

  - platform: gpio
    name: "Azimuth endstop max CW pos"
    id: azimuth_endstop_max_cw_pos
    icon: "mdi:arrow-expand-right"
    disabled_by_default: false
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_azimuth_axis
      sorting_weight: ${sorting_groups.azimuth_axis.azimuth_endstop_max_cw_pos}
    pin:
      mcp23xxx: mcp23017_main
      number: ${gpio_ids.azimuth_endstop_max_cw_pos}
      mode:
        input: true
        pullup: true
      inverted: false
    filters:
      - delayed_on: 5ms
    on_press:
      then:
        # Deactivate azimuth motor movements
        - switch.turn_off: motor_azimuth_plus_pin
        - switch.turn_off: motor_azimuth_minus_pin
        - lambda: ESP_LOGI("Azimuth Endstop CW:", "Triggered.");
    on_release:
      then:
        - lambda: ESP_LOGI("Azimuth Endstop CW:", "Released.");

  - platform: gpio
    name: "Azimuth endstop max CCW pos"
    id: azimuth_endstop_max_ccw_pos
    icon: "mdi:arrow-expand-left"
    disabled_by_default: false
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_azimuth_axis
      sorting_weight: ${sorting_groups.azimuth_axis.azimuth_endstop_max_ccw_pos}
    pin:
      mcp23xxx: mcp23017_main
      number: ${gpio_ids.azimuth_endstop_max_ccw_pos}
      mode:
        input: true
        pullup: true
      inverted: false
    filters:
      - delayed_on: 5ms   
    on_press:
      then:
        # Deactivate azimuth motor movements
        - switch.turn_off: motor_azimuth_plus_pin
        - switch.turn_off: motor_azimuth_minus_pin
        - lambda: ESP_LOGI("Azimuth Endstop CCW:", "Triggered.");
    on_release:
      then:
        - lambda: ESP_LOGI("Azimuth Endstop CCW:", "Released.");

### Button sensors


  # Any action on the control buttons deactivates all automations. These need to be reactivated manually. Caution: Activation of the stand_by_mode or cloudy_mode also activates the automations
  - platform: gpio
    name: "Button Up/CW"
    id: button_up_cw_physical
    icon: "mdi:arrow-expand-up"
    disabled_by_default: false
    web_server:
      sorting_group_id: sorting_group_buttons
      sorting_weight: ${sorting_groups.buttons.button_up_cw_physical}
    pin:
      mcp23xxx: mcp23017_main
      number: ${gpio_ids.button_up_cw_physical}
      mode:
        input: true
        pullup: true
      inverted: true
    filters:
      - delayed_on: 10ms 
    on_multi_click:
      - timing:
          - ON for at most 500ms
          - OFF for at least 100ms
          - ON for at most 500ms
          - OFF for at least 100ms
        then:
          - logger.log: "Double Clicked: Triggering CW rotation"
          - script.execute: perform_deactivate_all_automatic_axis_controls
          - script.execute: start_panel_rotation_clockwise
      - timing:
          - ON for 500ms to 3s
          - OFF for at least 0.2s
        then:
          - logger.log: "Single Long Clicked: Triggering Panel lifting"
          - script.execute: perform_deactivate_all_automatic_axis_controls
          - script.execute: start_panel_lifting
      - timing:
          - ON for at most 1s
          - OFF for at least 0.2s
        then:
          - logger.log: "Single Short Clicked: Triggering Stop all axis"
          - script.execute: stop_panel_elevation_movement
          - script.execute: stop_panel_rotation_movement

  # Any action on the control buttons deactivates all automations. These need to be reactivated manually. Caution: Activation of the stand_by_mode or cloudy_mode also activates the automations
  - platform: gpio
    name: "Button Down/CCW"
    id: button_down_ccw_physical
    icon: "mdi:arrow-expand-down"
    disabled_by_default: false
    web_server:
      sorting_group_id: sorting_group_buttons
      sorting_weight: ${sorting_groups.buttons.button_up_ccw_physical}
    pin:
      mcp23xxx: mcp23017_main
      number: ${gpio_ids.button_down_ccw_physical}
      mode:
        input: true
        pullup: true
      inverted: true
    filters:
      - delayed_on: 10ms   
    on_multi_click:
      - timing:
          - ON for at most 500ms
          - OFF for at least 100ms
          - ON for at most 500ms
          - OFF for at least 100ms
        then:
          - logger.log: "Double Clicked: Triggering CCW rotation"
          - script.execute: perform_deactivate_all_automatic_axis_controls
          - script.execute: start_panel_rotation_counterclockwise
      - timing:
          - ON for 500ms to 3s
          - OFF for at least 0.2s
        then:
          - logger.log: "Single Long Clicked: Triggering Panel lowering"
          - script.execute: perform_deactivate_all_automatic_axis_controls
          - script.execute: start_panel_lowering
      - timing:
          - ON for at most 1s
          - OFF for at least 0.2s
        then:
          - logger.log: "Single Short Clicked: Triggering Stop all axis"
          - script.execute: stop_panel_elevation_movement
          - script.execute: stop_panel_rotation_movement

globals:
  - id: global_display_rotation
    type: esphome::display::DisplayRotation
    restore_value: yes
    initial_value: 'DISPLAY_ROTATION_0_DEGREES'

  - id: panel_azimuth_angle_min_temp_value  # used to temporarily save the value during max|min estimation
    type: float
    restore_value: no
    initial_value: '0.0'

  - id: panel_elevation_angle_min_temp_value  # used to temporarily save the value during max|min estimation
    type: float
    restore_value: no
    initial_value: '0.0'

  - id: panel_elevation_angle_sensor_old_state  # used to estimate if the panel elevation axis is not moving when motor is moving
    type: float
    restore_value: no
    initial_value: '0.0'

  - id: panel_azimuth_angle_sensor_old_state  # used to estimate if the panel rotation axis is not moving when motor is moving
    type: float
    restore_value: no
    initial_value: '0.0'

  - id: panel_azimuth_moving_start_date  # used to save the date when a panel movement on the azimuth axis is initiated
    type: uint32_t
    restore_value: no
    initial_value: '0'

  - id: panel_elevation_moving_start_date  # used to save the date when a panel movement on the elevation axis is initiated
    type: uint32_t
    restore_value: no
    initial_value: '0' 

  - id: panel_elevation_target_reached_handled  # helper variable to ensure target reached success block is only executed once per movement session
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: panel_azimuth_target_reached_handled  # helper variable to ensure target reached success block is only executed once per movement session
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: angle_measurement_start_timestamp
    type: int
    restore_value: no
    initial_value: '0'

  - id: magnetic_declination_calibration_start_timestamp
    type: int
    restore_value: no
    initial_value: '0'

  - id: inital_angle_state_initialization_wait_start_timestamp
    type: int
    restore_value: no
    initial_value: '0'

  - id: global_owm_wind_speed_current
    type: float
    restore_value: yes
    initial_value: '123.456'

  - id: global_owm_wind_gusts_current
    type: float
    restore_value: yes
    initial_value: '123.456'

  - id: global_owm_cloud_coverage_current
    type: float
    restore_value: yes
    initial_value: '123.456'

  - id: global_owm_wind_speed_in_one_hour
    type: float
    restore_value: yes
    initial_value: '123.456'

  - id: global_owm_wind_gusts_in_one_hour
    type: float
    restore_value: yes
    initial_value: '123.456'

  - id: global_owm_cloud_coverage_in_one_hour
    type: float
    restore_value: yes
    initial_value: '123.456'

  - id: global_internet_connection_test_success
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: global_owm_api_key_valid
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: global_owm_last_data_retrieval_success
    type: int
    restore_value: yes
    initial_value: '0'

  - id: global_initial_sun_data_available
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: global_last_magnetic_calibration_success
    type: int
    restore_value: yes
    initial_value: '0'

  - id: global_last_periodic_magnetic_calibration_check
    type: int
    restore_value: no
    initial_value: '0'

  - id: global_perform_automatic_azimuth_angle_boundaries_measurement_running
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: global_perform_automatic_elev_angle_boundaries_measurement_running
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: global_magnetic_declination_calibration_running
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: global_azimuth_motor_blocked_high_current_fault_detected
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: global_azimuth_motor_not_connected_fault_detected
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: global_azimuth_motor_blocked_missing_angle_change_cw_fault_detected
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: global_azimuth_motor_blocked_missing_angle_change_ccw_fault_detected
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: global_elevation_motor_blocked_high_current_fault_detected
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: global_elevation_motor_not_connected_fault_detected
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: global_elevation_motor_blocked_missing_angle_change_while_lift_fault_detected
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: global_elevation_motor_blocked_missing_angle_change_while_lowering_fault_detected
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: global_magnetic_declination_calibration_fault_detected
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: global_azimuth_angle_calculation_fault_detected
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: global_elevation_angle_calculation_fault_detected
    type: bool
    restore_value: no
    initial_value: 'false'  
   
  # Weather hysteresis state tracking - Tracks whether each weather condition hysteresis is currently active (true) or inactive (false)
  # These variables implement the hysteresis logic to prevent rapid oscillation of stand by mode activation/deactivation
  - id: global_cloudy_mode_hysteresis_active
    type: bool
    restore_value: no
    initial_value: 'false'
    # Current state of cloud coverage hysteresis - Used to determine if cloudy mode is active due to high cloud coverage

  - id: global_wind_speed_hysteresis_active
    type: bool
    restore_value: no
    initial_value: 'false'
    # Current state of wind speed hysteresis - Used to determine if stand by mode is active due to high wind speed

  - id: global_wind_gusts_hysteresis_active
    type: bool
    restore_value: no
    initial_value: 'false'
    # Current state of wind gust hysteresis - Used to determine if stand by mode is active due to high wind gusts

  # Motor direction detection variables - Detect if motor rotates in correct direction based on sensor feedback
  - id: global_elevation_motor_start_angle
    type: float
    restore_value: no
    initial_value: '0.0'
    # Stores elevation angle at start of motor movement to detect if angle changes in expected direction

  - id: global_azimuth_motor_start_angle
    type: float
    restore_value: no
    initial_value: '0.0'
    # Stores azimuth angle at start of motor movement to detect if angle changes in expected direction

  - id: global_elevation_motor_wrong_direction_detected
    type: bool
    restore_value: no
    initial_value: 'false'
    # Flag set when elevation motor rotates in opposite direction than expected (inverted)

  - id: global_azimuth_motor_wrong_direction_detected
    type: bool
    restore_value: no
    initial_value: 'false'
    # Flag set when azimuth motor rotates in opposite direction than expected (inverted)

  - id: global_elevation_target_angle_timeout_start_timestamp
    type: int64_t
    restore_value: no
    initial_value: '0'
    # Timestamp (milliseconds) when elevation target angle adjustment was started - Used to detect timeout

  - id: global_azimuth_target_angle_timeout_start_timestamp
    type: int32_t
    restore_value: no
    initial_value: '0'
    # Timestamp (milliseconds) when azimuth target angle adjustment was started - Used to detect timeout

  - id: global_elevation_target_angle_timeout_detected
    type: bool
    restore_value: no
    initial_value: 'false'
    # Flag set when elevation target angle is not reached within configured timeout period

  - id: global_azimuth_target_angle_timeout_detected
    type: bool
    restore_value: no
    initial_value: 'false'
    # Flag set when azimuth target angle is not reached within configured timeout period

  # === Error Timestamp Variables ===
  # These variables store the timestamp (in seconds since epoch) when each error is detected
  # Used to display when each error occurred in German format (DD.MM.YYYY HH:MM:SS)

  - id: global_elevation_motor_wrong_direction_timestamp
    type: time_t
    restore_value: no
    initial_value: '0'
    # Timestamp when elevation motor wrong direction error was detected

  - id: global_azimuth_motor_wrong_direction_timestamp
    type: time_t
    restore_value: no
    initial_value: '0'
    # Timestamp when azimuth motor wrong direction error was detected

  - id: global_elevation_target_angle_timeout_timestamp
    type: time_t
    restore_value: no
    initial_value: '0'
    # Timestamp when elevation target angle timeout error was detected

  - id: global_azimuth_target_angle_timeout_timestamp
    type: time_t
    restore_value: no
    initial_value: '0'
    # Timestamp when azimuth target angle timeout error was detected

  - id: global_elevation_motor_blocked_high_current_timestamp
    type: time_t
    restore_value: no
    initial_value: '0'
    # Timestamp when elevation motor blocked (high current) error was detected

  - id: global_elevation_motor_not_connected_timestamp
    type: time_t
    restore_value: no
    initial_value: '0'
    # Timestamp when elevation motor not connected error was detected

  - id: global_azimuth_motor_blocked_high_current_timestamp
    type: time_t
    restore_value: no
    initial_value: '0'
    # Timestamp when azimuth motor blocked (high current) error was detected

  - id: global_azimuth_motor_not_connected_timestamp
    type: time_t
    restore_value: no
    initial_value: '0'
    # Timestamp when azimuth motor not connected error was detected

  - id: global_elevation_motor_blocked_missing_angle_lift_timestamp
    type: time_t
    restore_value: no
    initial_value: '0'
    # Timestamp when elevation motor blocked (missing angle change during lift) error was detected

  - id: global_elevation_motor_blocked_missing_angle_lower_timestamp
    type: time_t
    restore_value: no
    initial_value: '0'
    # Timestamp when elevation motor blocked (missing angle change during lower) error was detected

  - id: global_azimuth_motor_blocked_missing_angle_cw_timestamp
    type: time_t
    restore_value: no
    initial_value: '0'
    # Timestamp when azimuth motor blocked (missing angle change during CW) error was detected

  - id: global_azimuth_motor_blocked_missing_angle_ccw_timestamp
    type: time_t
    restore_value: no
    initial_value: '0'
    # Timestamp when azimuth motor blocked (missing angle change during CCW) error was detected

  - id: global_elevation_angle_calculation_fault_timestamp
    type: time_t
    restore_value: no
    initial_value: '0'
    # Timestamp when elevation angle calculation fault was detected

  - id: global_azimuth_angle_calculation_fault_timestamp
    type: time_t
    restore_value: no
    initial_value: '0'
    # Timestamp when azimuth angle calculation fault was detected

  - id: global_magnetic_declination_calibration_fault_timestamp
    type: time_t
    restore_value: no
    initial_value: '0'
    # Timestamp when magnetic declination calibration fault was detected
   
script:

  - id: perform_stop_any_running_calibration
    mode: single
    then:
      - lambda: |-
          if (id(magnetic_declination_calibration_active).state)
          {
            ESP_LOGE("Magnetic declination calibration:", "Calibration stopped.");
            id(global_magnetic_declination_calibration_running) = false;
          }

          if (id(elev_angle_boundaries_measurement_active).state)
          {
            ESP_LOGE("Elevation angle measurement:", "Calibration stopped.");
            id(global_perform_automatic_elev_angle_boundaries_measurement_running) = false;
          }

          if (id(azimuth_angle_boundaries_measurement_active).state)
          {
            ESP_LOGE("Azimuth angle measurement:", "Calibration stopped.");
            id(global_perform_automatic_azimuth_angle_boundaries_measurement_running) = false;
          }

  - id: perform_status_led_update
    mode: single
    then:
      - lambda: |-
          float internal_brightness = id(sun_data).elevation() > 0 ? id(led_internal_brightness_day).state / 100.0 : id(led_internal_brightness_night).state / 100.0;
          float external_brightness = id(sun_data).elevation() > 0 ? id(led_external_brightness_day).state / 100.0 : id(led_external_brightness_night).state / 100.0;

          bool fault_detected = false;
          bool semi_fault_detected = false;
          bool calibration_active = id(elev_angle_boundaries_measurement_active).state or id(magnetic_declination_calibration_active).state or id(azimuth_angle_boundaries_measurement_active).state;
          bool automations_not_active = !id(auto_set_panel_azimuth_target_to_sun_azimuth).state or !id(auto_set_panel_elev_target_to_sun_elev).state or !id(auto_control_azimuth_angle).state or !id(auto_control_elevation_angle).state;

          // ================= Wifi status led settings ===============================
          if (!id(wifi_connected_binary_sensor).state)
          {
            id(wifi_status_led).turn_on().set_brightness(internal_brightness).set_rgb(${led_color_red[0]}, ${led_color_red[1]}, ${led_color_red[2]}).perform();
          } else
          {
            id(wifi_status_led).turn_on().set_brightness(internal_brightness).set_rgb(${led_color_green[0]}, ${led_color_green[1]}, ${led_color_green[2]}).perform();
          }

          // ================= Sensor status led settings =============================

          if (!id(imu_sensor_ready).state 
              or !id(azimuth_motor_sensor_ready).state 
              or !id(elevation_motor_sensor_ready).state)
          {
            id(sensor_status_led).turn_on().set_brightness(internal_brightness).set_rgb(${led_color_red[0]}, ${led_color_red[1]}, ${led_color_red[2]}).perform();
            fault_detected = true;
          } else if (id(azimuth_angle_calculation_fault_detected).state
                      or id(azimuth_axis_not_calibrated).state
                      or id(elevation_angle_calculation_fault_detected).state
                      or id(elevation_axis_not_calibrated).state
                      or id(magnetic_declination_calibration_fault_detected).state)
          {
            id(sensor_status_led).turn_on().set_brightness(internal_brightness).set_rgb(${led_color_yellow[0]}, ${led_color_yellow[1]}, ${led_color_yellow[2]}).perform();
            semi_fault_detected = true;
          } else
          {
            id(sensor_status_led).turn_on().set_brightness(internal_brightness).set_rgb(${led_color_green[0]}, ${led_color_green[1]}, ${led_color_green[2]}).perform();
          }

          // ================= Motor status led settings ===========================

          if (!id(azimuth_motor_sensor_ready).state 
              or !id(elevation_motor_sensor_ready).state)
          {
            id(motor_status_led).turn_on().set_brightness(internal_brightness).set_rgb(${led_color_red[0]}, ${led_color_red[1]}, ${led_color_red[2]}).perform();
            fault_detected = true;
          } else if (id(azimuth_motor_blocked_current).state
                      or id(azimuth_motor_not_connected_low_current).state
                      or id(azimuth_motor_no_angle_change_cw).state
                      or id(azimuth_motor_no_angle_change_ccw).state
                      or id(azimuth_motor_wrong_direction_detected_binary_sensor).state
                      or id(azimuth_target_angle_timeout_detected_binary_sensor).state
                      or id(elevation_motor_blocked_current).state
                      or id(elevation_motor_not_connected_low_current).state
                      or id(elevation_motor_no_angle_change_lift).state
                      or id(elevation_motor_no_angle_change_lowering).state
                      or id(elevation_motor_wrong_direction_detected_binary_sensor).state
                      or id(elevation_target_angle_timeout_detected_binary_sensor).state)
          {
            id(motor_status_led).turn_on().set_brightness(internal_brightness).set_rgb(${led_color_yellow[0]}, ${led_color_yellow[1]}, ${led_color_yellow[2]}).perform();
            semi_fault_detected = true;
          } else
          {
            id(motor_status_led).turn_on().set_brightness(internal_brightness).set_rgb(${led_color_green[0]}, ${led_color_green[1]}, ${led_color_green[2]}).perform();
          }

          // ================== External status led settings =========================

          if (calibration_active)
          {
            id(main_status_extern_led).turn_on().set_brightness(external_brightness).set_rgb(${led_color_blue[0]}, ${led_color_blue[1]}, ${led_color_blue[2]}).set_effect("Fast Pulse").perform();
          } else if (fault_detected)
          {
            id(main_status_extern_led).turn_on().set_brightness(external_brightness).set_rgb(${led_color_red[0]}, ${led_color_red[1]}, ${led_color_red[2]}).set_effect("None").perform();
          } else if (semi_fault_detected)
          {
            id(main_status_extern_led).turn_on().set_brightness(external_brightness).set_rgb(${led_color_yellow[0]}, ${led_color_yellow[1]}, ${led_color_yellow[2]}).set_effect("None").perform();
          } else if (automations_not_active)
          {
            id(main_status_extern_led).turn_on().set_brightness(external_brightness).set_rgb(${led_color_yellow[0]}, ${led_color_yellow[1]}, ${led_color_yellow[2]}).set_effect("Fast Pulse").perform();
          } else
          {
            id(main_status_extern_led).turn_on().set_brightness(external_brightness).set_rgb(${led_color_green[0]}, ${led_color_green[1]}, ${led_color_green[2]}).set_effect("None").perform();
          }
          

  - id: perform_publish_states_to_status_text_sensors
    mode: single
    then:
      - lambda: |-
          
          // ############### owm_status_text
          if (!id(owm_api_key_entered).state)
          {
            id(owm_status_text).publish_state("OWM API Key is not entered. Auto OWM data retrieval deactivated. Enter a valid OWM API key to use this feature.");        
          } else if (!id(global_owm_api_key_valid))
          {
            id(owm_status_text).publish_state("OWM API Key is not valid. Auto OWM data retrieval deactivated. Enter a valid OWM API key to use this feature.");         
          }



          // ############### network_and_internet_status_text
          if (!id(global_internet_connection_test_success))
          {
            id(network_and_internet_status_text).publish_state("Test URL not reachable. Internet connection might not be available.");         
          } else
          {
            id(network_and_internet_status_text).publish_state("Normal");      
          }



          // ############### elevation_motor_sensor_status_text
          if (!id(elevation_motor_sensor_ready).state)
          {
            id(elevation_motor_sensor_status_text).publish_state("Elevation Motor current sensor not ready. Check correct I2C address and solder jumper settings.");         
          } else if (!id(elevation_motor_voltage_is_valid).state)
          {
            id(elevation_motor_sensor_status_text).publish_state("Error: Motor voltage is not valid.");
          }  else
          {
            id(elevation_motor_sensor_status_text).publish_state("Normal");      
          }



          // ############### azimuth_motor_sensor_status_text
          if (!id(elevation_and_azimuth_axis_mode_activated).state)
          {
            id(azimuth_motor_sensor_status_text).publish_state("\"Axis control mode\" is set to \"Elevation Axis only\". Azimuth axis is deactivated.");         
          } else if (!id(azimuth_motor_sensor_ready).state)
          {
            id(azimuth_motor_sensor_status_text).publish_state("Azimuth Motor current sensor not ready. Check correct I2C address and solder jumper settings.");         
          } else if (!id(azimuth_motor_voltage_is_valid).state)
          {
            id(azimuth_motor_sensor_status_text).publish_state("Error: Motor voltage is not valid.");
          } else
          {
            id(azimuth_motor_sensor_status_text).publish_state("Normal");      
          }



          // ############### Helper lambda for German time formatting (DD.MM.YYYY HH:MM:SS)
          auto format_german_time = [](time_t ts) -> std::string {
            if (ts == 0) return "";
            struct tm timeinfo;
            localtime_r(&ts, &timeinfo);
            char buf[20];
            strftime(buf, sizeof(buf), "%d.%m.%Y %H:%M:%S", &timeinfo);
            return std::string(buf);
          };

          // ############### elevation_axis_status_text
          if (id(global_elevation_motor_wrong_direction_detected))
          {
            std::string message = "ERROR: Elevation motor rotates in wrong direction! Motor direction is inverted. Enable \"Invert elevation motor direction\" to fix this.";
            std::string ts_str = format_german_time(id(global_elevation_motor_wrong_direction_timestamp));
            if (!ts_str.empty()) message += " (Detected: " + ts_str + ")";
            id(elevation_axis_status_text).publish_state(message);         
          } else if (id(global_elevation_target_angle_timeout_detected))
          {
            std::string message = "ERROR: Elevation target angle not reached within configured timeout! Check motor and mechanics or increase timeout value.";
            std::string ts_str = format_german_time(id(global_elevation_target_angle_timeout_timestamp));
            if (!ts_str.empty()) message += " (Detected: " + ts_str + ")";
            id(elevation_axis_status_text).publish_state(message);         
          } else if (id(global_elevation_motor_wrong_direction_detected))
          {
            std::string message = "ERROR: Elevation motor rotates in wrong direction! Motor direction is inverted. Enable \"Invert elevation motor direction\" to fix this.";
            std::string ts_str = format_german_time(id(global_elevation_motor_wrong_direction_timestamp));
            if (!ts_str.empty()) message += " (Detected: " + ts_str + ")";
            id(elevation_axis_status_text).publish_state(message);         
          } else if (id(elev_angle_boundaries_measurement_active).state)
          {
            id(elevation_axis_status_text).publish_state("Elevation angle boundaries measurement active...");         
          } else if (id(global_elevation_angle_calculation_fault_detected))
          {
            std::string message = "Elevation angle measurement. Check the motor and mechanics.";
            std::string ts_str = format_german_time(id(global_elevation_angle_calculation_fault_timestamp));
            if (!ts_str.empty()) message += " (Detected: " + ts_str + ")";
            id(elevation_axis_status_text).publish_state(message);
          } else if (id(elevation_angle_max_min_not_estimated).state)
          {
            id(elevation_axis_status_text).publish_state("Elevation max|min angle not estimated yet. Start elevation angle estimation to use automatic angle calculation.");         
          } else if (!id(auto_set_panel_elev_target_to_sun_elev).state)
          {
            id(elevation_axis_status_text).publish_state("Auto elevation target angle calculation is deactivated. Activate \"Auto calculate elevation angle\" to fix this.");         
          } else if (!id(auto_control_elevation_angle).state)
          {
            id(elevation_axis_status_text).publish_state("Elevation angle control is deactivated. Activate \"Auto control elevation angle\" to fix this.");         
          } else if (!id(auto_control_elevation_angle_activation_at_boot).state)
          {
            id(elevation_axis_status_text).publish_state("Elevation angle control auto activation is deactivated. Activate \"Auto control elevation angle activation at boot\" to fix this.");         
          } else
          {
            id(elevation_axis_status_text).publish_state("Normal");      
          }



          // ############### azimuth_axis_status_text
          if (id(global_azimuth_motor_wrong_direction_detected))
          {
            std::string message = "ERROR: Azimuth motor rotates in wrong direction! Motor direction is inverted. Enable \"Invert azimuth motor direction\" to fix this.";
            std::string ts_str = format_german_time(id(global_azimuth_motor_wrong_direction_timestamp));
            if (!ts_str.empty()) message += " (Detected: " + ts_str + ")";
            id(azimuth_axis_status_text).publish_state(message);         
          } else if (id(global_azimuth_target_angle_timeout_detected))
          {
            std::string message = "ERROR: Azimuth target angle not reached within configured timeout! Check motor and mechanics or increase timeout value.";
            std::string ts_str = format_german_time(id(global_azimuth_target_angle_timeout_timestamp));
            if (!ts_str.empty()) message += " (Detected: " + ts_str + ")";
            id(azimuth_axis_status_text).publish_state(message);         
          } else if (id(global_azimuth_motor_wrong_direction_detected))
          {
            std::string message = "ERROR: Azimuth motor rotates in wrong direction! Motor direction is inverted. Enable \"Invert azimuth motor direction\" to fix this.";
            std::string ts_str = format_german_time(id(global_azimuth_motor_wrong_direction_timestamp));
            if (!ts_str.empty()) message += " (Detected: " + ts_str + ")";
            id(azimuth_axis_status_text).publish_state(message);         
          } else if (id(magnetic_declination_calibration_active).state)
          {
            id(azimuth_axis_status_text).publish_state("Magnetic declination calibration active...");         
          } else if (id(azimuth_angle_boundaries_measurement_active).state)
          {
            id(azimuth_axis_status_text).publish_state("Azimuth angle boundaries measurement active...");         
          } else if (!id(elevation_and_azimuth_axis_mode_activated).state)
          {
            id(azimuth_axis_status_text).publish_state("\"Axis control mode\" is set to \"Elevation Axis only\". Azimuth axis is deactivated.");         
          } else if (id(global_azimuth_angle_calculation_fault_detected))
          {
            std::string message = "Azimuth angle measurement failed. Check the motor and mechanics.";
            std::string ts_str = format_german_time(id(global_azimuth_angle_calculation_fault_timestamp));
            if (!ts_str.empty()) message += " (Detected: " + ts_str + ")";
            id(azimuth_axis_status_text).publish_state(message);         
          } else if (id(global_magnetic_declination_calibration_fault_detected))
          {
            std::string message = "Magnetic declination calibration failed.";
            std::string ts_str = format_german_time(id(global_magnetic_declination_calibration_fault_timestamp));
            if (!ts_str.empty()) message += " (Detected: " + ts_str + ")";
            id(azimuth_axis_status_text).publish_state(message);         
          } else if (id(azimuth_angle_max_min_not_estimated).state)
          {
            id(azimuth_axis_status_text).publish_state("Azimuth max|min angle not estimated yet. Start azimuth angle estimation to use automatic angle calculation.");         
          } else if (!id(auto_set_panel_azimuth_target_to_sun_azimuth).state)
          {
            id(azimuth_axis_status_text).publish_state("Auto azimuth target angle calculation is deactivated. Activate \"Auto calculate azimuth angle\" to fix this.");         
          } else if (!id(auto_control_azimuth_angle).state)
          {
            id(azimuth_axis_status_text).publish_state("Azimuth angle control is deactivated. Activate \"Auto control azimuth angle\" to fix this.");         
          } else if (!id(auto_control_azimuth_angle_activation_at_boot).state)
          {
            id(azimuth_axis_status_text).publish_state("Azimuth angle control auto activation is deactivated. Activate \"Auto control azimuth angle activation at boot\" to fix this.");         
          } else 
          {
            id(azimuth_axis_status_text).publish_state("Normal");      
          }



          // ############### azimuth_motor_status_text
          if (!id(elevation_and_azimuth_axis_mode_activated).state)
          {
            id(azimuth_motor_status_text).publish_state("\"Axis control mode\" is set to \"Elevation Axis only\". Azimuth axis is deactivated.");         
          } else if (id(global_azimuth_motor_wrong_direction_detected))
          {
            std::string message = "ERROR: Azimuth motor rotates in wrong direction! Motor direction is inverted. Enable \"Invert azimuth motor direction\" to fix this.";
            std::string ts_str = format_german_time(id(global_azimuth_motor_wrong_direction_timestamp));
            if (!ts_str.empty()) message += " (Detected: " + ts_str + ")";
            id(azimuth_motor_status_text).publish_state(message);         
          } else if (id(global_azimuth_motor_blocked_high_current_fault_detected))
          {
            std::string message = "${status_text_messages.motor_blocked_high_current}";
            std::string ts_str = format_german_time(id(global_azimuth_motor_blocked_high_current_timestamp));
            if (!ts_str.empty()) message += " (Detected: " + ts_str + ")";
            id(azimuth_motor_status_text).publish_state(message);         
          } else if (id(global_azimuth_motor_not_connected_fault_detected))
          {
            std::string message = "${status_text_messages.motor_connection_error_rotation}";
            std::string ts_str = format_german_time(id(global_azimuth_motor_not_connected_timestamp));
            if (!ts_str.empty()) message += " (Detected: " + ts_str + ")";
            id(azimuth_motor_status_text).publish_state(message);         
          } else if (id(global_azimuth_motor_blocked_missing_angle_change_cw_fault_detected))
          {
            std::string message = "${status_text_messages.motor_blocked_angle_cw_not_changing}";
            std::string ts_str = format_german_time(id(global_azimuth_motor_blocked_missing_angle_cw_timestamp));
            if (!ts_str.empty()) message += " (Detected: " + ts_str + ")";
            id(azimuth_motor_status_text).publish_state(message);         
          } else if (id(global_azimuth_motor_blocked_missing_angle_change_ccw_fault_detected))
          {
            std::string message = "${status_text_messages.motor_blocked_angle_ccw_not_changing}";
            std::string ts_str = format_german_time(id(global_azimuth_motor_blocked_missing_angle_ccw_timestamp));
            if (!ts_str.empty()) message += " (Detected: " + ts_str + ")";
            id(azimuth_motor_status_text).publish_state(message);     
          } else
          {
            id(azimuth_motor_status_text).publish_state("Normal");      
          }

          
          // ############### elevation_motor_status_text
          if (id(global_elevation_motor_wrong_direction_detected))
          {
            std::string message = "ERROR: Elevation motor rotates in wrong direction! Motor direction is inverted. Enable \"Invert elevation motor direction\" to fix this.";
            std::string ts_str = format_german_time(id(global_elevation_motor_wrong_direction_timestamp));
            if (!ts_str.empty()) message += " (Detected: " + ts_str + ")";
            id(elevation_motor_status_text).publish_state(message);         
          } else if (id(global_elevation_motor_blocked_high_current_fault_detected))
          {
            std::string message = "${status_text_messages.motor_blocked_high_current}";
            std::string ts_str = format_german_time(id(global_elevation_motor_blocked_high_current_timestamp));
            if (!ts_str.empty()) message += " (Detected: " + ts_str + ")";
            id(elevation_motor_status_text).publish_state(message);         
          } else if (id(global_elevation_motor_not_connected_fault_detected))
          {
            std::string message = "${status_text_messages.motor_connection_error_elevation}";
            std::string ts_str = format_german_time(id(global_elevation_motor_not_connected_timestamp));
            if (!ts_str.empty()) message += " (Detected: " + ts_str + ")";
            id(elevation_motor_status_text).publish_state(message);         
          } else if (id(global_elevation_motor_blocked_missing_angle_change_while_lift_fault_detected))
          {
            std::string message = "${status_text_messages.motor_blocked_angle_up_not_changing}";
            std::string ts_str = format_german_time(id(global_elevation_motor_blocked_missing_angle_lift_timestamp));
            if (!ts_str.empty()) message += " (Detected: " + ts_str + ")";
            id(elevation_motor_status_text).publish_state(message);         
          } else if (id(global_elevation_motor_blocked_missing_angle_change_while_lowering_fault_detected))
          {
            std::string message = "${status_text_messages.motor_blocked_angle_down_not_changing}";
            std::string ts_str = format_german_time(id(global_elevation_motor_blocked_missing_angle_lower_timestamp));
            if (!ts_str.empty()) message += " (Detected: " + ts_str + ")";
            id(elevation_motor_status_text).publish_state(message);         
          } else
          {
            id(elevation_motor_status_text).publish_state("Normal");      
          }



          // ############### gnss_status_text
          if (!id(gnss_sensor_ready).state)
          {
            id(gnss_status_text).publish_state("${status_text_messages.gnss_not_ready}");         
          } else if (id(gnss_reception_quality).state <= 1)
          {
            id(gnss_status_text).publish_state("${status_text_messages.gnss_signal_quality_poor}");         
          } else
          {
            id(gnss_status_text).publish_state("Normal");      
          }



          // ############### imu_status_text
          if (!id(imu_sensor_ready).state)
          {
            id(imu_status_text).publish_state("${status_text_messages.imu_not_ready}");         
          } else if (id(global_magnetic_declination_calibration_fault_detected))
          {
            id(imu_status_text).publish_state("Magnetic declination calibration failed.");         
          } else if (id(magnetic_declination_calibration_active).state)
          {
            id(imu_status_text).publish_state("Magnetic declination calibration active...");         
          } else
          {
            id(imu_status_text).publish_state("Normal");      
          }
          

  # do initializations as soon as sun data and time is available and valid
  - id: perform_inital_angle_state_initialization
    mode: single
    then:
      - if:
          condition:
            and:
              - lambda: 'return !bool(id(global_initial_sun_data_available));'    # we only want to execute this once after boot and when the sun data is initially available and valid
          then:
            - lambda: |-
                id(inital_angle_state_initialization_wait_start_timestamp) = id(ds3231_time).now().timestamp;  // save starttime for time based abort condition

                ESP_LOGE("Initial angle initialization:", "Waiting for valid sun and time data to initialize angles...");
                ESP_LOGE("Initial angle initialization:", "Process started at: %i", id(inital_angle_state_initialization_wait_start_timestamp));
                ESP_LOGE("Initial angle initialization:", "Timeout set to: %i", id(inital_angle_state_initialization_wait_start_timestamp) + int(${inital_angle_state_initialization_max_wait_time}));
                
            - while:
                condition:
                  and:
                    - lambda: 'return !isnan(id(sun_azimuth).state);' 
                    - lambda: 'return !isnan(id(sun_elevation).state);' 
                    - lambda: 'return !id(ds3231_sensor_ready).state;'     
                    - lambda: 'return id(ds3231_time).now().timestamp <= (id(inital_angle_state_initialization_wait_start_timestamp) + int(${inital_angle_state_initialization_max_wait_time}));'
                then:
                  - lambda: |-
                      ESP_LOGE("Initial angle initialization:", "Waiting for sun and time data. Timeout in %i seconds...", (id(inital_angle_state_initialization_wait_start_timestamp) + int(${inital_angle_state_initialization_max_wait_time})) - id(ds3231_time).now().timestamp) ;
                  - delay: 1s

            - if:
                condition:
                  and:
                    - lambda: 'return !isnan(id(sun_azimuth).state);' 
                    - lambda: 'return !isnan(id(sun_elevation).state);' 
                    - lambda: 'return id(ds3231_sensor_ready).state;'
                then:
                  - script.execute: perform_stand_by_mode_activation_check 
                  - script.wait: perform_stand_by_mode_activation_check

                  - script.execute: perform_sun_elevation_target_angle_calculation 
                  - script.wait: perform_sun_elevation_target_angle_calculation
                  
                  - script.execute: perform_sun_azimuth_target_angle_calculation 
                  - script.wait: perform_sun_azimuth_target_angle_calculation
                
                  - if:
                      condition:
                        - switch.is_on: auto_control_elevation_angle_activation_at_boot
                      then:
                        - switch.turn_on: auto_control_elevation_angle
                
                  - if:
                      condition:
                        - switch.is_on: auto_control_azimuth_angle_activation_at_boot
                      then:
                        - switch.turn_on: auto_control_azimuth_angle

                  - lambda: 'id(global_initial_sun_data_available) = true;'
                else:
                  - lambda: |-
                        ESP_LOGE("Initial angle initialization::", "Failed due to timeout. Retry planned when sun or time data is available.");


  # deactivate all automatic controls
  - id: perform_deactivate_all_automatic_axis_controls
    mode: single
    then:
      - switch.turn_off: auto_control_elevation_angle
      - switch.turn_off: auto_control_azimuth_angle
      - lambda: |-     
          ESP_LOGI("Auto control:", "All automatic controls deactivated.");


  # checks if the threshold for cloudy mode control is reached or not and enables/disables the cloudy mode if needed
  - id: perform_automatic_cloudy_mode_control_estimation
    mode: single
    then:
      - lambda: |-     
          if (id(auto_cloudy_mode_control).state)
          {
            if (id(owm_cloud_coverage_above_threshold).state)
            {
              id(cloudy_mode_active).turn_on();  
              ESP_LOGI("Cloudy mode control:", "Cloudiness threshold reached. Enabling Switch: \"Cloudy Mode Active\".");
            }
            else
            {
              id(cloudy_mode_active).turn_off();  
              ESP_LOGI("Cloudy mode control:", "Cloudiness threshold undercut. Disabling Switch: \"Cloudy Mode Active\".");
            }
          }

  # checks if the stand by mode needs to be activated/deactivated based on the available data
  # checks if the threshold for wind speed or wind gusts is reached or not and enables/disables the stand by mode if needed
  - id: perform_stand_by_mode_activation_check
    mode: single
    then:
      - lambda: |-
          bool reason_sun_control_active = id(auto_stand_by_mode_via_sun_elevation_control).state;
          bool reason_sun = id(stand_by_mode_trigger_sun_elevation).state;

          bool reason_expired_control_active = id(auto_stand_by_mode_if_owm_data_expired_control).state;
          bool reason_expired = id(stand_by_mode_trigger_expired_owm_data).state;

          bool reason_wind_control_active = id(auto_wind_protection_control).state;
          bool reason_wind = id(stand_by_mode_trigger_high_winds).state;

          if (id(auto_stand_by_mode_estimation).state)
          {
            if ((reason_sun_control_active && reason_sun) or (reason_expired_control_active && reason_expired) or (reason_wind_control_active && reason_wind)) 
            {
              if(!id(stand_by_mode_active).state)
              {
                if (reason_sun) 
                {
                  ESP_LOGE("Stand by mode control", "Sun elevation angle is below trigger angle. Enabling Switch: \"Stand By Mode Active\".");
                }

                if (reason_expired) 
                {
                  ESP_LOGE("Stand by mode control", "OWM data is too old. Initiated safety shutdown. Enabling Switch: \"Stand By Mode Active\".");
                }

                if (reason_wind) 
                {
                  ESP_LOGE("Stand by mode control", "Wind speed/gusts above threshold. Enabling Switch: \"Stand By Mode Active\".");
                }

                id(stand_by_mode_active).turn_on();
              }
            } else
            { 
              if(id(stand_by_mode_active).state)
              {
                if (reason_sun_control_active && !reason_sun) 
                {
                  ESP_LOGE("Stand by mode control", "Sun elevation angle is above trigger angle. Disabling Switch: \"Stand By Mode Active\".");
                }

                if (reason_expired_control_active && !reason_expired) 
                {
                  ESP_LOGE("Stand by mode control", "OWM data is renewed. Disabling Switch: \"Stand By Mode Active\".");
                }

                if (reason_wind_control_active && !reason_wind) 
                {
                  ESP_LOGE("Stand by mode control", "Wind speed/gusts below threshold. Disabling Switch: \"Stand By Mode Active\".");
                }

                id(stand_by_mode_active).turn_off();  
              }                      
            }          
          }

  # checks if the elevation angle differs from the elevation target angle and drives it to the elevation target angle range
  - id: perform_automatic_elevation_angle_adjustment
    mode: single
    then:
      - lambda: |-
          // only execute this if there is no calibration or measurement running
          if (!id(elevation_axis_not_calibrated).state)
          {
            id(panel_imu).update();
            id(panel_elevation_angle_sensor).update();

            if (id(panel_within_elev_target_angle_range_binary_sensor).state)
            {
              if (id(panel_lifting_planned).state or id(panel_lowering_planned).state)
              {
                id(stop_panel_elevation_movement).execute();  
              }          
            } else if (id(panel_lifting_to_elev_target_angle_needed_binary_sensor).state)
            {
              if (!id(panel_lifting_planned).state)
              {
                id(start_panel_lifting).execute();
              }
            } else if (id(panel_lowering_to_elev_target_angle_needed_binary_sensor).state)
            {
              if (!id(panel_lowering_planned).state)
              {
                id(start_panel_lowering).execute();
                ESP_LOGE("Auto control elevation angle:", "Lowering started.");
              }
            }
          }

  # checks if the elevation angle differs from the elevation target angle and drives it to the elevation target angle range
  - id: perform_automatic_azimuth_angle_adjustment
    mode: single
    then:
      - lambda: |-
          // only execute this if there is no calibration or measurement running
          if (!id(azimuth_axis_not_calibrated).state)
          {
            id(panel_imu).update();    
            id(panel_compass_heading).update();     

             //=== lets check first that no lift process is needed: lift prio > rotation prio ===

            if (id(auto_control_elevation_angle).state 
              and (id(panel_lifting_to_elev_target_angle_needed_binary_sensor).state or id(panel_lowering_to_elev_target_angle_needed_binary_sensor).state)
              and !id(panel_within_elev_target_angle_range_binary_sensor).state
              and (id(panel_lowering_planned).state or id(panel_lifting_planned).state))      
            {
              if (id(panel_rotation_in_cw_planned).state or id(panel_rotation_in_ccw_planned).state)  
              {
                id(stop_panel_rotation_movement).execute();
                ESP_LOGE("Auto control azimuth angle:", "Stopped, because panel movement is active and has higher prio than rotation.");
              }          
            } else
            {
              if (id(panel_within_azimuth_target_angle_range_binary_sensor).state)
              {
                if (id(panel_rotation_in_cw_planned).state or id(panel_rotation_in_ccw_planned).state)
                {
                  id(stop_panel_rotation_movement).execute();
                }  
              } else if (id(panel_left_from_azimuth_target_angle_binary_sensor).state)
              {
                if (!id(panel_rotation_in_cw_planned).state)
                {
                  id(start_panel_rotation_clockwise).execute();
                }
              } else if (id(panel_right_from_azimuth_target_angle_binary_sensor).state)
              {
                if (!id(panel_rotation_in_ccw_planned).state)
                {
                  id(start_panel_rotation_counterclockwise).execute();
                }
              } 
            }
          }

  # Check if elevation target angle is reached within configured timeout period when auto control is active
  - id: perform_elevation_target_angle_timeout_check
    mode: single
    then:
      - lambda: |-
          if (id(auto_elevation_target_angle_timeout_detection_on_off).state and !id(elevation_axis_not_calibrated).state and id(auto_control_elevation_angle).state)
          {
            // Check if panel is now in target range (target reached successfully)
            if (id(panel_within_elev_target_angle_range_binary_sensor).state && id(panel_elevation_moving_start_date) > 0 && !id(panel_elevation_target_reached_handled))
            {
              id(global_elevation_target_angle_timeout_detected) = false;
              id(panel_elevation_target_reached_handled) = true;  // Mark as handled
              id(panel_elevation_moving_start_date) = 0;  // Reset movement start date to indicate movement is finished
              ESP_LOGE("Elevation timeout check:", "Target angle reached within timeout successfully");
            }

            // Check if timeout has been exceeded (using panel_elevation_moving_start_date)
            else if (id(panel_elevation_moving_start_date) > 0 && !id(panel_within_elev_target_angle_range_binary_sensor).state)
            {
              int64_t elapsed_milliseconds = (esp_timer_get_time() / 1000) - id(panel_elevation_moving_start_date);
              int64_t timeout_milliseconds = int(${elevation_target_angle_timeout}) * 1000;
              
              if (elapsed_milliseconds >= timeout_milliseconds)
              {
                if (!id(global_elevation_target_angle_timeout_detected))
                {
                  id(global_elevation_target_angle_timeout_detected) = true;
                  id(global_elevation_target_angle_timeout_timestamp) = id(ds3231_time).now().timestamp;
                  id(auto_control_elevation_angle).turn_off();
                  ESP_LOGE("Elevation timeout check:", "Target angle not reached within %i seconds (Elapsed: %.1fs)! Stopping automatic control.", ${elevation_target_angle_timeout}, elapsed_milliseconds / 1000.0);
                }
              }
            }

          } else
          {
            // Reset timeout detection if auto control or detection is disabled
            id(global_elevation_target_angle_timeout_detected) = false;
          }

  # Check if azimuth target angle is reached within configured timeout period when auto control is active
  - id: perform_azimuth_target_angle_timeout_check
    mode: single
    then:
      - lambda: |-
          if (id(auto_azimuth_target_angle_timeout_detection_on_off).state && !id(azimuth_axis_not_calibrated).state && id(auto_control_azimuth_angle).state)
          {
            // Check if panel is now in target range (target reached successfully)
            if (id(panel_within_azimuth_target_angle_range_binary_sensor).state && id(panel_azimuth_moving_start_date) > 0 && !id(panel_azimuth_target_reached_handled))
            {
              id(global_azimuth_target_angle_timeout_detected) = false;
              id(panel_azimuth_target_reached_handled) = true;  // Mark as handled
              id(panel_azimuth_moving_start_date) = 0;  // Reset movement start date to indicate movement is finished
              ESP_LOGE("Azimuth timeout check:", "Target angle reached within timeout successfully");
            }

            // Check if timeout has been exceeded (using panel_azimuth_moving_start_date)
            else if (id(panel_azimuth_moving_start_date) > 0 && !id(panel_within_azimuth_target_angle_range_binary_sensor).state)
            {
              int64_t elapsed_milliseconds = (esp_timer_get_time() / 1000) - id(panel_azimuth_moving_start_date);
              int64_t timeout_milliseconds = int(${azimuth_target_angle_timeout}) * 1000;
              
              if (elapsed_milliseconds >= timeout_milliseconds)
              {
                if (!id(global_azimuth_target_angle_timeout_detected))
                {
                  id(global_azimuth_target_angle_timeout_detected) = true;
                  id(global_azimuth_target_angle_timeout_timestamp) = id(ds3231_time).now().timestamp;
                  id(auto_control_azimuth_angle).turn_off();
                  ESP_LOGE("Azimuth timeout check:", "Target angle not reached within %i seconds (Elapsed: %.1fs)! Stopping automatic control.", ${azimuth_target_angle_timeout}, elapsed_milliseconds / 1000.0);
                }
              }
            }
          } else
          {
            // Reset timeout detection if auto control or detection is disabled
            id(global_azimuth_target_angle_timeout_detected) = false;
          }

  - id: perform_automatic_elev_angle_boundaries_measurement
    mode: single
    then:
      - if:
          condition:
            binary_sensor.is_on: imu_sensor_ready
          then:
            - lambda: |-
                // anounce that the automatic measurement is running
                id(global_perform_automatic_elev_angle_boundaries_measurement_running) = true;
                id(global_elevation_angle_calculation_fault_detected) = false;

                ESP_LOGE("Elevation angle measurement:", "Preparing evelation angle measrurement. \"Auto angle adjustment mode\" is deactivated...");

                // Increase boundary values to avoid sw motor endstop before physical endstop of linear actuator motor is reached

                auto call = id(panel_elevation_angle_max).make_call();
                call.set_value(${initial_value.panel_elev_angle_max});
                call.perform();

                auto call2 = id(panel_elevation_angle_min).make_call();
                call2.set_value(${initial_value.panel_elev_angle_min});
                call2.perform();
                
                // Close panel lifter and wait until motor current is zero
                id(start_panel_lowering).execute();

                id(motor_elevation_electrical_sensor).update();

                id(angle_measurement_start_timestamp) = id(ds3231_time).now().timestamp;  // save starttime for time based abort condition of measurement

                ESP_LOGE("Elevation angle measurement:", "Starting panel lowering and wait for motor idle state...");
                ESP_LOGE("Elevation angle measurement:", "Process started at: %i", id(angle_measurement_start_timestamp));
                ESP_LOGE("Elevation angle measurement:", "Timeout set to: %i", id(angle_measurement_start_timestamp) + int(${elevation_measurement_lowering_max_wait_time}));
                
            - delay: 1s
            - while:
                condition:
                  and:                    
                    - lambda: 'return id(global_perform_automatic_elev_angle_boundaries_measurement_running);'
                    - lambda: 'return id(elevation_motor_is_running_binary_sensor).state;'
                    - lambda: 'return id(ds3231_time).now().timestamp <= (id(angle_measurement_start_timestamp) + int(${elevation_measurement_lowering_max_wait_time}));'
                then:
                  - lambda: |-
                      ESP_LOGE("Elevation angle measurement:", "Lowering process running. Timeout in %i seconds...", (id(angle_measurement_start_timestamp) + int(${elevation_measurement_lowering_max_wait_time})) - id(ds3231_time).now().timestamp) ;
                      id(motor_elevation_electrical_sensor).update();
                      yield();
                  - delay: 1s

            - if:
                condition:
                  and:
                    - lambda: 'return id(global_perform_automatic_elev_angle_boundaries_measurement_running);'
                    - lambda: 'return id(ds3231_time).now().timestamp <= (id(angle_measurement_start_timestamp) + int(${elevation_measurement_lowering_max_wait_time}));'
                then:
                  - lambda: |-      
                      // Lets update the sensors first...
                      id(panel_imu).update();
                      id(panel_elevation_angle_sensor).update();  

                      // ...and then save the current angle as new boundary value to a temp variable. It will be saved to the final variable when the whole measurement is finished successfully.
                      float precision = 0.1;  // multiplicator to round to defined precision

                      //auto call2 = id(panel_elevation_angle_min).make_call();
                      //auto call = id(panel_elevation_angle_min_temp_value).make_call();
                      //call.set_value(floor(id(panel_elevation_angle_sensor).state / precision + 0.5) * precision);
                      //call.perform();

                      id(panel_elevation_angle_min_temp_value) = floor(id(panel_elevation_angle_sensor).state / precision + 0.5) * precision;

                      ESP_LOGE("Elevation angle measurement:", "Minium elevation angle estimated successfully!");
                      ESP_LOGE("Elevation angle measurement:", "New panel elevation minimum value saved (temporarily): %2.1f°", id(panel_elevation_angle_min_temp_value));
                      
                      // Now open panel lifter and wait until motor current is zero to start the detection of the max angle
                      id(start_panel_lifting).execute();

                      id(motor_elevation_electrical_sensor).update();
                      
                      id(angle_measurement_start_timestamp) = id(ds3231_time).now().timestamp;  // save starttime for time based abort condition of measurement

                      ESP_LOGE("Elevation angle measurement:", "Starting panel lifting and wait for motor idle state...");
                      ESP_LOGE("Elevation angle measurement:", "Process started at: %i", id(angle_measurement_start_timestamp));
                      ESP_LOGE("Elevation angle measurement:", "Timeout set to: %i", id(angle_measurement_start_timestamp) + int(${elevation_measurement_lifting_max_wait_time}));

                  - delay: 1s
                  - while:
                      condition:
                        and:
                          - lambda: 'return id(global_perform_automatic_elev_angle_boundaries_measurement_running);'
                          - lambda: 'return id(elevation_motor_is_running_binary_sensor).state;'  
                          - lambda: 'return id(ds3231_time).now().timestamp <= (id(angle_measurement_start_timestamp) + int(${elevation_measurement_lifting_max_wait_time}));'
                      then:
                        - lambda: |-
                            ESP_LOGE("Elevation angle measurement:", "Lifting process running. Timeout in %i seconds...", (id(angle_measurement_start_timestamp) + int(${elevation_measurement_lifting_max_wait_time})) - id(ds3231_time).now().timestamp) ;
                            id(motor_elevation_electrical_sensor).update();
                            yield();
                        - delay: 1s

                  - if:
                      condition:
                        and:
                          - lambda: 'return id(global_perform_automatic_elev_angle_boundaries_measurement_running);'
                          - lambda: 'return id(ds3231_time).now().timestamp <= (id(angle_measurement_start_timestamp) + int(${elevation_measurement_lifting_max_wait_time}));'
                      then:
                        - lambda: |-
                            // Lets update the sensors first...
                            id(panel_imu).update();
                            id(panel_elevation_angle_sensor).update();  

                            // ...and then save the current max angle as new boundary value
                            float precision = 0.1;  // multiplicator to round to defined precision

                            auto call = id(panel_elevation_angle_max).make_call();
                            call.set_value(floor(id(panel_elevation_angle_sensor).state / precision + 0.5) * precision);
                            call.perform();

                            // ...and also save the previous saved min value to the final variable
                            auto call2 = id(panel_elevation_angle_min).make_call();
                            call2.set_value(id(panel_elevation_angle_min_temp_value));
                            call2.perform();

                            ESP_LOGE("Elevation angle measurement:", "Finished succesfully!");
                            ESP_LOGE("Elevation angle measurement:", "New panel elevation minimum value is: %2.1f°", id(panel_elevation_angle_min).state);
                            ESP_LOGE("Elevation angle measurement:", "New panel elevation maximum value is: %2.1f°", id(panel_elevation_angle_max).state);
                      else:
                        # Handle failure during lifting
                        - lambda: |-
                            id(global_elevation_angle_calculation_fault_detected) = true;
                            id(global_elevation_angle_calculation_fault_timestamp) = id(ds3231_time).now().timestamp;
                        - if:
                            condition:
                              - lambda: 'return id(ds3231_time).now().timestamp <= id(angle_measurement_start_timestamp) + int(${elevation_measurement_lifting_max_wait_time});'
                            then:
                              - lambda: |-
                                  ESP_LOGE("Elevation angle measurement:", "Measurement failed (during lifting) due to external abort. Check the motor and mechanics.");
                            else:
                              - lambda: |-
                                  ESP_LOGE("Elevation angle measurement:", "Measurement failed due to timeout (during lifting). Check the motor and mechanics.");
                else:
                  # Handle failure during lowering
                  - lambda: |-
                      id(global_elevation_angle_calculation_fault_detected) = true;
                      id(global_elevation_angle_calculation_fault_timestamp) = id(ds3231_time).now().timestamp;
                  - if:
                      condition:
                        - lambda: 'return id(ds3231_time).now().timestamp <= id(angle_measurement_start_timestamp) + int(${elevation_measurement_lowering_max_wait_time});'
                      then:
                        - lambda: |-
                            ESP_LOGE("Elevation angle measurement:", "Measurement failed (during lowering) due to external abort. Check the motor and mechanics.");
                      else:
                        - lambda: |-
                            ESP_LOGE("Elevation angle measurement:", "Measurement failed due to timeout (during lowering). Check the motor and mechanics.");

            - lambda: |-
                // anounce that the automatic measurement is finished
                id(global_perform_automatic_elev_angle_boundaries_measurement_running) = false;
          else:
            - lambda: |-
                ESP_LOGE("Elevation angle measurement:", "IMU not ready. Calibration aborted.");

  - id: perform_automatic_azimuth_angle_boundaries_measurement
    mode: single
    then:
      - if:
          condition:
            binary_sensor.is_on: imu_sensor_ready
          then:  
            - lambda: |-
                ESP_LOGE("Azimuth angle measurement:", "Preparing Azimuth angle measurement: Starting magnetic declination calibration first...");
            - script.execute: perform_magnetic_declination_calibration
            - script.wait: perform_magnetic_declination_calibration

            - lambda: |-
                // anounce that the automatic measurement is running
                id(global_perform_automatic_azimuth_angle_boundaries_measurement_running) = true;
                id(global_azimuth_angle_calculation_fault_detected) = false;

                // Increase boundary values to avoid sw motor endstop before physical endstop of linear actuator motor is reached
                auto call = id(panel_azimuth_angle_max).make_call();
                call.set_value(${initial_value.panel_azimuth_angle_max});
                call.perform();

                auto call2 = id(panel_azimuth_angle_min).make_call();
                call2.set_value(${initial_value.panel_azimuth_angle_min});
                call2.perform();
                
                // Now rotate the panel CCW(left) until the physical endstop is triggered to start the detection of the max angle...
                id(start_panel_rotation_counterclockwise).execute();
                
                id(angle_measurement_start_timestamp) = id(ds3231_time).now().timestamp;  // save starttime for time based abort condition of measurement

                ESP_LOGE("Azimuth angle measurement:", "Moving motor in CCW direction until physical endstop is triggered...");
                ESP_LOGE("Azimuth angle measurement:", "Process started at: %i", id(angle_measurement_start_timestamp));
                ESP_LOGE("Azimuth angle measurement:", "Timeout set to: %i", id(angle_measurement_start_timestamp) + int(${azimuth_measurement_max_wait_time}));

            - delay: 500ms
            - lambda: 'id(motor_azimuth_electrical_sensor).update();'

            - while:
                condition:
                  and:
                    - lambda: 'return id(global_perform_automatic_azimuth_angle_boundaries_measurement_running);'
                    - lambda: 'return !id(azimuth_endstop_max_ccw_pos).state;'
                    - lambda: 'return id(azimuth_motor_is_running_binary_sensor).state;'
                    - lambda: 'return id(ds3231_time).now().timestamp <= (id(angle_measurement_start_timestamp) + int(${azimuth_measurement_max_wait_time}));'
                then:
                  - lambda: |-
                      ESP_LOGE("Azimuth angle measurement:", "Rotating in direction: CCW. Timeout in %i seconds...", (id(angle_measurement_start_timestamp) + int(${azimuth_measurement_max_wait_time})) - id(ds3231_time).now().timestamp) ;
                      id(motor_azimuth_electrical_sensor).update();
                      yield();
                  - delay: 1s

            - lambda: |-
                ESP_LOGE("Azimuth angle measurement:", "Moving in CCW(left) direction finished.");

            - if:
                condition:
                  and:
                    - lambda: 'return id(global_perform_automatic_azimuth_angle_boundaries_measurement_running);'
                    - lambda: 'return id(ds3231_time).now().timestamp <= (id(angle_measurement_start_timestamp) + int(${azimuth_measurement_max_wait_time}));'
                then:
                  - lambda: |-
                      // Lets update the sensors first...
                      id(panel_imu).update();
                      id(panel_compass_heading).update(); 

                      // ...and then save the current angle as new boundary value to a temp variable. It will be saved to the final variable when the whole measurement is finished successfully.
                      float precision = 0.1;  // multiplicator to round to defined precision

                      //auto call = id(panel_azimuth_angle_min).make_call();
                      //call.set_value(floor(id(panel_compass_heading).state / precision + 0.5) * precision);
                      //call.perform();

                      id(panel_azimuth_angle_min_temp_value) = floor(id(panel_compass_heading).state / precision + 0.5) * precision;

                      ESP_LOGE("Azimuth angle measurement:", "Minium azimuth max (CCW) angle estimated successfully!");
                      ESP_LOGE("Azimuth angle measurement:", "New panel azimuth max (CCW) value saved (temporarily): %2.1f", id(panel_azimuth_angle_min_temp_value));

                      // Moving motor in CW(right) direction and wait until motor current is zero
                      id(start_panel_rotation_clockwise).execute();
                      
                      id(angle_measurement_start_timestamp) = id(ds3231_time).now().timestamp;  // save starttime for time based abort condition of measurement

                      ESP_LOGE("Azimuth angle measurement:", "Moving motor in CCW direction until physical endstop is triggered...");
                      ESP_LOGE("Azimuth angle measurement:", "Process started at: %i", id(angle_measurement_start_timestamp));
                      ESP_LOGE("Azimuth angle measurement:", "Timeout set to: %i", id(angle_measurement_start_timestamp) + int(${azimuth_measurement_max_wait_time}));

                  - delay: 500ms
                  - lambda: |-
                      id(motor_azimuth_electrical_sensor).update();
                      ESP_LOGE("Azimuth angle measurement:", "CW Endstop: %d, Motor: %d", id(azimuth_endstop_max_cw_pos).state, id(azimuth_motor_is_running_binary_sensor).state);

                  - while:
                      condition:
                        and:
                          - lambda: 'return id(global_perform_automatic_azimuth_angle_boundaries_measurement_running);'
                          - lambda: 'return !id(azimuth_endstop_max_cw_pos).state;'
                          - lambda: 'return id(azimuth_motor_is_running_binary_sensor).state;'
                          - lambda: 'return id(ds3231_time).now().timestamp <= (id(angle_measurement_start_timestamp) + int(${azimuth_measurement_max_wait_time}));'
                      then:
                        - lambda: |-
                            ESP_LOGE("Azimuth angle measurement:", "Rotating in direction: CW. Timeout in %i seconds...", (id(angle_measurement_start_timestamp) + int(${azimuth_measurement_max_wait_time})) - id(ds3231_time).now().timestamp);                      
                            id(motor_azimuth_electrical_sensor).update();
                            yield();
                        - delay: 1s

                  - lambda: |-
                      ESP_LOGE("Azimuth angle measurement:", "Moving in CW(right) direction finished. Endstop: %d, Motor: %d", id(azimuth_endstop_max_cw_pos).state, id(azimuth_motor_is_running_binary_sensor).state);

                  - if:
                      condition:
                        and:
                          - lambda: 'return id(global_perform_automatic_azimuth_angle_boundaries_measurement_running);'
                          - lambda: 'return id(ds3231_time).now().timestamp <= (id(angle_measurement_start_timestamp) + int(${azimuth_measurement_max_wait_time}));'
                      then:
                        - lambda: |-
                            // Lets update the sensors first...
                            id(panel_imu).update();
                            id(panel_compass_heading).update(); 

                            // ...and then save the current angle as new boundary value
                            float precision = 0.1;  // multiplicator to round to defined precision
                            
                            float azimuth_cw_angle = floor(id(panel_compass_heading).state / precision + 0.5) * precision;
                            float azimuth_ccw_angle = id(panel_azimuth_angle_min_temp_value);
                            
                            // Validate endstop distance is approximately 225° (±x%)
                            // Expected distance: 225°, Tolerance: 5% = ±11.25°
                            float expected_distance = ${azimuth_endstop_distance_target};
                            float tolerance_percent = ${azimuth_endstop_distance_tolerance_percent};
                            float tolerance_degrees = (expected_distance * tolerance_percent) / 100.0;
                            
                            float actual_distance = abs(azimuth_cw_angle - azimuth_ccw_angle);
                            if (actual_distance > 180.0)
                            {
                              actual_distance = 360.0 - actual_distance;  // Handle wrap-around (e.g., 350° to 10° = 20°)
                            }
                            
                            float min_allowed = expected_distance - tolerance_degrees;
                            float max_allowed = expected_distance + tolerance_degrees;
                            
                            ESP_LOGE("Azimuth angle measurement:", "Validating endstop distance...");
                            ESP_LOGE("Azimuth angle measurement:", "CCW endstop angle: %2.1f°", azimuth_ccw_angle);
                            ESP_LOGE("Azimuth angle measurement:", "CW endstop angle: %2.1f°", azimuth_cw_angle);
                            ESP_LOGE("Azimuth angle measurement:", "Measured distance: %2.1f° (Expected: %2.1f° ±%2.1f°)", actual_distance, expected_distance, tolerance_degrees);
                            
                            if (actual_distance >= min_allowed && actual_distance <= max_allowed)
                            {
                              // Distance is valid - apply the measured values
                              auto call = id(panel_azimuth_angle_max).make_call();
                              call.set_value(azimuth_cw_angle);
                              call.perform();

                              auto call2 = id(panel_azimuth_angle_min).make_call();
                              call2.set_value(azimuth_ccw_angle);
                              call2.perform();

                              ESP_LOGE("Azimuth angle measurement:", "Finished succesfully!");
                              ESP_LOGE("Azimuth angle measurement:", "Endstop distance validation: PASSED (distance within tolerance)");
                              ESP_LOGE("Azimuth angle measurement:", "New panel azimuth max (CCW) value is: %2.1f", id(panel_azimuth_angle_min).state);
                              ESP_LOGE("Azimuth angle measurement:", "New panel azimuth min (CW) value is: %2.1f", id(panel_azimuth_angle_max).state);
                            } else
                            {
                              // Distance is INVALID - reject the measurement
                              id(global_azimuth_angle_calculation_fault_detected) = true;
                              id(global_azimuth_angle_calculation_fault_timestamp) = id(ds3231_time).now().timestamp;
                              
                              ESP_LOGE("Azimuth angle measurement:", "VALIDATION FAILED!");
                              ESP_LOGE("Azimuth angle measurement:", "Endstop distance out of tolerance!");
                              ESP_LOGE("Azimuth angle measurement:", "Expected distance: %2.1f° (±%2.1f°, allowed: %2.1f° to %2.1f°)", expected_distance, tolerance_degrees, min_allowed, max_allowed);
                              ESP_LOGE("Azimuth angle measurement:", "Measured distance: %2.1f°", actual_distance);
                              ESP_LOGE("Azimuth angle measurement:", "Measurement aborted - values NOT applied. Check mechanical alignment of azimuth axis.");
                            }
                      else:
                        # Handle failure during CCW rotation
                        - lambda: |-
                            id(global_azimuth_angle_calculation_fault_detected) = true;
                            id(global_azimuth_angle_calculation_fault_timestamp) = id(ds3231_time).now().timestamp;
                        - if:
                            condition:
                              - lambda: 'return id(ds3231_time).now().timestamp <= id(angle_measurement_start_timestamp) + int(${azimuth_measurement_max_wait_time});'
                            then:
                              - lambda: |-
                                  ESP_LOGE("Azimuth angle measurement:", "Measurement failed (during  CCW rotation) due to external abort. Check the motor and mechanics.");
                            else:
                              - lambda: |-
                                  ESP_LOGE("Azimuth angle measurement:", "Measurement failed (during CCW rotation) due to timeout. Check the motor and mechanics.");
                else:
                  # Handle failure during CW rotation
                  - lambda: |-
                      id(global_azimuth_angle_calculation_fault_detected) = true;
                      id(global_azimuth_angle_calculation_fault_timestamp) = id(ds3231_time).now().timestamp;
                  - if:
                      condition:
                        - lambda: 'return id(ds3231_time).now().timestamp <= id(angle_measurement_start_timestamp) + int(${azimuth_measurement_max_wait_time});'
                      then:
                        - lambda: |-
                            ESP_LOGE("Azimuth angle measurement:", "Measurement failed (during  CW rotation) due to external abort. Check the motor and mechanics.");
                      else:
                        - lambda: |-
                            ESP_LOGE("Azimuth angle measurement:", "Measurement failed (during CW rotation) due to timeout. Check the motor and mechanics.");
            - lambda: |-
                // anounce that the automatic measurement is finished
                id(global_perform_automatic_azimuth_angle_boundaries_measurement_running) = false;
          else:
            - lambda: |-
                ESP_LOGE("Azimuth angle measurement:", "IMU not ready. Calibration aborted.");

  - id: perform_sun_elevation_target_angle_calculation
    mode: single
    then:
      - lambda: |-
          if (!id(elevation_axis_not_calibrated).state 
              and ( bool(id(global_initial_sun_data_available)) or id(stand_by_mode_active).state )
              and ( 
                  (id(elevation_and_azimuth_axis_mode_activated).state and !id(azimuth_axis_not_calibrated).state)
                  or id(elevation_axis_mode_activated).state
                  or id(stand_by_mode_active).state 
                  or id(cloudy_mode_active).state
                  )              
              )
          {
            // some constants first
            float pi = 3.1415926535;
            float deg2rad = pi/180.0;
            float rad2deg = 180.0/pi;
            float precision = 0.1;  // multiplicator to round to defined precision               
            
            ESP_LOGI("Elevation angle calculation:", "Current elevation target value is %1.0f°.", id(panel_elev_target_angle).state);

            float tmp_panel_elev_target_value = id(panel_elev_target_angle).state;
            
            if (id(stand_by_mode_active).state)
            {
                tmp_panel_elev_target_value = id(stand_by_mode_elevation_target_angle).state;

                if (id(panel_is_in_stand_by_position).state)
                {
                  ESP_LOGE("Elevation angle calculation:", "Stand by mode active. Panel is in Stand by position.");
                } else
                {
                  ESP_LOGE("Elevation angle calculation:", "Stand by mode active. Lets bring the panel elevation angle to %1.0f°.", id(stand_by_mode_elevation_target_angle).state);
                }


            } else if (id(cloudy_mode_active).state)
            {
                // in case of cloudy mode is active we want to put the panel as parallel to the ground as possible to maximize energy yield
                tmp_panel_elev_target_value = ${cloudy_mode_elevation_target_angle};
                ESP_LOGE("Elevation angle calculation:", "Cloudy mode active. Lets put the panel as parallel to the ground as possible.");
            } else
            {
              if (id(auto_set_panel_elev_target_to_sun_elev).state)
              {
                if (id(elevation_axis_mode_activated).state) // This is the setting for single-axis mode. (Only elevation axis will be controlled by sunchronizer)
                {
                  tmp_panel_elev_target_value = (asin(cos(id(sun_elevation).state * deg2rad) * cos(id(sun_azimuth).state * deg2rad - id(panel_azimuth_orientation).state * deg2rad))) * rad2deg;
                  // regarding tha above formula the infos here, excel-calculations (and chatGPT) helped me a lot: https://community.home-assistant.io/t/ha-solar-tracker/571372

                  ESP_LOGI("Elevation angle calculation:", "Single-axis mode used: Target elevation angle calculation considers sun elevation & sun azimuth angle.");
                } else if (id(elevation_and_azimuth_axis_mode_activated).state)  // This is the setting for dual-axis mode. (Both axis will be controlled by sunchronizer)
                {
                  ESP_LOGI("Elevation angle calculation:", "Dual-axis mode used: Target elevation angle calculation considers sun elevation angle only.");              

                  tmp_panel_elev_target_value = 90.0 - id(sun_elevation).state; // This is the setting for 2-axis mode (Panel elevation & azimuth axis can be controlled by sunchronizer)
            
                  // limit target angle to max or min possible
                  if (tmp_panel_elev_target_value > id(panel_elevation_angle_max).state)
                  {
                      tmp_panel_elev_target_value = id(panel_elevation_angle_max).state;
                      ESP_LOGW("Elevation angle calculation:", "Target angle (%1.0f°) greater than max possible panel elevation angle. Target angle limited to max possible value(%1.0f°).", tmp_panel_elev_target_value, id(panel_elevation_angle_max).state);
                  } else if (tmp_panel_elev_target_value < id(panel_elevation_angle_min).state)
                  {
                      tmp_panel_elev_target_value = id(panel_elevation_angle_min).state;
                      ESP_LOGW("Elevation angle calculation:", "Angle smaller than min possible panel elevation angle. Target angle limited to min possible value(%1.0f°).", id(panel_elevation_angle_min).state);
                  }
                }

                ESP_LOGI("Elevation angle calculation:", "Sun elevation value is %2.0f", id(sun_elevation).state);

              }
            }

            // only update the target angle value when the calculation lead to a different value than the current one
            if (abs(id(panel_elev_target_angle).state-tmp_panel_elev_target_value)>0.001)
            {
              tmp_panel_elev_target_value = floor(tmp_panel_elev_target_value / precision + 0.5) * precision;

              auto call = id(panel_elev_target_angle).make_call();
              call.set_value(tmp_panel_elev_target_value);
              call.perform();

              ESP_LOGI("Elevation angle calculation:", "New elevation target value is %2.0f", id(panel_elev_target_angle).state);
            }
          } else
          {
            if (id(elevation_axis_not_calibrated).state)
            {
              ESP_LOGE("Elevation angle calculation:", "Postponed due to missing elevation axis calibration...");
            } else if (id(elevation_and_azimuth_axis_mode_activated).state and id(azimuth_axis_not_calibrated).state)
            {
              ESP_LOGE("Elevation angle calculation:", "Postponed due to missing azimuth axis calibration...");
            }
            {
              ESP_LOGW("Elevation angle calculation:", "Waiting for sun data to start calculation...");
            }
          }

  - id: perform_sun_azimuth_target_angle_calculation
    mode: single
    then:
      - lambda: |-
          if (!id(azimuth_axis_not_calibrated).state and (bool(id(global_initial_sun_data_available)) or id(stand_by_mode_active).state)) // if there is no sun data available we skip this and wait until there is valid sun angle data available
          {
            // some constants first
            float precision = 0.1;  // multiplicator to round to defined precision

            ESP_LOGI("Azimuth angle calculation:", "Current azimuth target value is %1.0f°.", id(panel_azimuth_target_angle).state);

            float tmp_panel_azimuth_target_value = id(panel_azimuth_target_angle).state;

            if (id(stand_by_mode_active).state)
            {
              ESP_LOGI("Azimuth angle calculation:", "Stand by mode active. Lets bring the panel azimuth angle to %1.0f°.", id(stand_by_mode_azimuth_target_angle).state);
              tmp_panel_azimuth_target_value = id(stand_by_mode_azimuth_target_angle).state;
            } else           
            {
              if (id(auto_set_panel_azimuth_target_to_sun_azimuth).state)
              {
                 tmp_panel_azimuth_target_value = id(sun_azimuth).state;

                // limit target angle to max or min possible
                if (tmp_panel_azimuth_target_value > id(panel_azimuth_angle_max).state)
                {
                    tmp_panel_azimuth_target_value = id(panel_azimuth_angle_max).state;
                    ESP_LOGI("Azimuth angle calculation:", "Target angle greater than max possible panel azimuth angle. Target angle limited to max possible value(%1.0f°).", id(panel_azimuth_angle_max).state);
                } else if (tmp_panel_azimuth_target_value < id(panel_azimuth_angle_min).state)
                {
                    tmp_panel_azimuth_target_value = id(panel_azimuth_angle_min).state;
                    ESP_LOGI("Azimuth angle calculation:", "Angle smaller than min possible panel azimuth angle. Target angle limited to min possible value(%1.0f°).", id(panel_azimuth_angle_min).state);
                }

                ESP_LOGI("Azimuth angle calculation:", "Sun azimuth value is %2.0f", id(sun_azimuth).state);

              }              
            }

            // only update the target angle value when the calculation lead to a different value than the current one
            if (abs(id(panel_azimuth_target_angle).state-tmp_panel_azimuth_target_value)>0.001)
            {
              tmp_panel_azimuth_target_value = floor(tmp_panel_azimuth_target_value / precision + 0.5) * precision;

              auto call = id(panel_azimuth_target_angle).make_call();
              call.set_value(tmp_panel_azimuth_target_value);
              call.perform();

              ESP_LOGI("Azimuth angle calculation:", "New azimuth target value is %2.0f", tmp_panel_azimuth_target_value);
            }
          } else
          {
            if (id(azimuth_axis_not_calibrated).state)
            {
              ESP_LOGE("Azimuth angle calculation:", "Postponed due to missing azimuth axis calibration...");
            } else
            {
              ESP_LOGW("Azimuth angle calculation:", "Waiting for sun data to start calculation...");
            }
          }

  # this script executes tasks that need to be executed at midnight
  #- id: execute_midnight_tasks
  #  mode: single
  #  then:
  #    - lambda: |-   
  #        // Reset that no magnetic declination calibration was done today
  #        //id(global_magnetic_calibration_executed_today) = false;

  # this script checks if a magnetic delicnation calibration is needed
  - id: check_if_magnetic_declination_calibration_is_needed
    mode: single
    then:
      - if:
          condition:
            and:              
              - lambda: 'return !id(magnetic_calibration_executed_today).state;'
              - lambda: 'return !id(stand_by_mode_active).state;'
              - lambda: 'return id(ds3231_sensor_ready).state;'
              - lambda: 'return id(elevation_and_azimuth_axis_mode_activated).state;'
          then:
            - lambda: |-
                ESP_LOGE("Magnetic declination calibration:", "Calibration is needed!");
            - script.execute: perform_magnetic_declination_calibration
            - script.wait: perform_magnetic_declination_calibration

  # this script checks periodically if a magnetic declination calibration is needed and executes it if the interval has passed
  # it uses a timestamp to track when the last check was performed
  - id: check_if_magnetic_declination_calibration_is_needed_periodic
    mode: single
    then:
      - if:
          condition:
            and:
              - lambda: 'return id(magnetic_calibration_periodic_check_enabled).state;'  # Only run if periodic check is enabled
              - lambda: 'return !id(stand_by_mode_active).state;'  # Don't run if in stand by mode
              - lambda: 'return id(ds3231_sensor_ready).state;'
              - lambda: 'return id(elevation_and_azimuth_axis_mode_activated).state;'
              - lambda: |-
                  // Check if enough time has passed since last periodic check
                  time_t now = id(ds3231_time).now().timestamp;
                  time_t last_check = id(global_last_periodic_magnetic_calibration_check);
                  long interval_seconds = ${magnetic_calibration_periodic_check_interval_minutes} * 60;
                  return (now - last_check) >= interval_seconds;
          then:
            - lambda: |-
                id(global_last_periodic_magnetic_calibration_check) = id(ds3231_time).now().timestamp;  // Update last check timestamp
            - if:
                condition:
                  - lambda: 'return !id(magnetic_calibration_executed_today).state;'  # Only execute if not done today
                then:
                  - lambda: |-
                      ESP_LOGE("Magnetic declination calibration (periodic):", "Periodic check triggered - calibration is needed!");
                  - script.execute: perform_magnetic_declination_calibration
                  - script.wait: perform_magnetic_declination_calibration
                else:
                  - lambda: |-
                      ESP_LOGE("Magnetic declination calibration (periodic):", "Periodic check passed - calibration already done today.");

  # this script performs an automatic magnetic declination calibration by driving the azimuth axis to the CCW endstop and saving this angle as new reference
  # this was introduced to increase acuracy of the IMU by reducing drift over time of the magnetometer
  - id: perform_magnetic_declination_calibration
    mode: single
    then:
      - if:
          condition:
            binary_sensor.is_on: imu_sensor_ready
          then:
            #- if: 
            #    condition:
            #      binary_sensor.is_off: azimuth_endstop_max_ccw_pos
            #    then:
            - lambda: |-    
                // anounce that the calibration is running
                id(global_magnetic_declination_calibration_running) = true;
                id(global_magnetic_declination_calibration_fault_detected) = false;

                // Now rotate the panel CCW(left) until the physical endstop is triggered.
                id(start_panel_rotation_counterclockwise).execute();
                
                id(magnetic_declination_calibration_start_timestamp) = id(ds3231_time).now().timestamp;  // save starttime for time based abort condition of measurement

                ESP_LOGE("Magnetic declination calibration:", "Process started at: %i", id(magnetic_declination_calibration_start_timestamp));
                ESP_LOGE("Magnetic declination calibration:", "Timeout set to: %i", id(magnetic_declination_calibration_start_timestamp) + int(${magnetic_declination_calibration_max_wait_time}));
                ESP_LOGE("Magnetic declination calibration:", "Moving motor in CCW(left) direction until physical endstop is triggered...");

            - delay: 1s
            - lambda: |-
                id(motor_azimuth_electrical_sensor).update();

            - while:
                condition:
                  and:                    
                    - lambda: 'return id(global_magnetic_declination_calibration_running);'
                    - lambda: 'return !id(azimuth_endstop_max_ccw_pos).state;'
                    - lambda: 'return id(panel_rotation_in_ccw_active).state;'
                    - lambda: 'return id(ds3231_time).now().timestamp <= id(magnetic_declination_calibration_start_timestamp) + int(${magnetic_declination_calibration_max_wait_time});'
                then:
                  - lambda: |-
                      ESP_LOGE("Magnetic declination calibration:", "Rotating in direction: CCW. Timeout in %i seconds...", (id(magnetic_declination_calibration_start_timestamp) + int(${magnetic_declination_calibration_max_wait_time})) - id(ds3231_time).now().timestamp);                      
                      id(motor_azimuth_electrical_sensor).update();
                      yield();
                  - delay: 1s

            - if:
                condition:
                  and:
                    - lambda: 'return id(global_magnetic_declination_calibration_running);'
                    - lambda: 'return id(ds3231_time).now().timestamp <= id(magnetic_declination_calibration_start_timestamp) + int(${magnetic_declination_calibration_max_wait_time});'
                then:
                  - if:
                      condition:
                        - lambda: 'return id(azimuth_endstop_max_ccw_pos).state;'
                      then:
                        - lambda: |-
                            ESP_LOGE("Magnetic declination calibration:", "Moving in CCW(left) direction finished.");
                        - script.execute: perform_save_current_magnetic_declination
                        - script.wait: perform_save_current_magnetic_declination
                      else: 
                        - lambda: |-
                            ESP_LOGE("Magnetic declination calibration:", "Calibration failed (during CCW rotation) due to endstop not reached. Check the motor and mechanics.");
                            id(global_magnetic_declination_calibration_fault_detected) = true;
                            id(global_magnetic_declination_calibration_fault_timestamp) = id(ds3231_time).now().timestamp;
                else:
                  - lambda: |-
                      id(global_magnetic_declination_calibration_fault_detected) = true;
                      id(global_magnetic_declination_calibration_fault_timestamp) = id(ds3231_time).now().timestamp;
                  - if:
                      condition:
                        - lambda: 'return id(ds3231_time).now().timestamp <= id(magnetic_declination_calibration_start_timestamp) + int(${magnetic_declination_calibration_max_wait_time});'
                      then:
                        - lambda: |-
                            ESP_LOGE("Magnetic declination calibration:", "Calibration failed (during CCW rotation) due to external abort. Check the motor and mechanics.");
                      else:
                        - lambda: |-
                            ESP_LOGE("Magnetic declination calibration:", "Calibration failed (during CCW rotation) due to timeout. Check the motor and mechanics.");

            - lambda: |-    
                // anounce that the calibration is finished
                id(global_magnetic_declination_calibration_running) = false;
          else:
            - lambda: |-
                ESP_LOGE("Magnetic declination calibration:", "IMU not ready. Calibration aborted.");

  # this script calculates and saves the magnetic declination
  - id: perform_save_current_magnetic_declination
    mode: single
    then:
      - if:
          condition:
            binary_sensor.is_on: imu_sensor_ready
          then:
            - lambda: |-
                if (id(azimuth_endstop_max_ccw_pos).state)
                {
                  ESP_LOGE("Magnetic declination calculation:", "CCW Endstop is triggered. Calculating...");

                  auto call = id(magnetic_declination).make_call();
                  call.set_value(0.0);
                  call.perform();

                  id(magnetic_declination).update();
                  id(panel_compass_heading).update();

                  float new_value = float(${initial_value.ccw_endstop_azimuth_pointing_direction}) - id(panel_compass_heading).state;
                  new_value = (new_value < -180) ? new_value + 360.0 : new_value;

                  auto call2 = id(magnetic_declination).make_call();
                  call2.set_value(new_value);
                  call2.perform();

                  ESP_LOGE("Magnetic declination calculation:", "...done. New value is %2.1f", new_value);
                  
                  // Save that a magnetic declination calibration was done today
                  id(global_last_magnetic_calibration_success) = id(ds3231_time).now().timestamp;  // save timestamp of last magnetic calibration
                  id(last_magnetic_calibration_text).update();

                } else
                {
                  ESP_LOGE("Magnetic declination calculation:", "CCW Endstop needs to be triggered and properly aligned to perform calculation. Please read the manual for proper calculation.");
                }
          else:
            - lambda: |-
                ESP_LOGE("Magnetic declination calculation:", "IMU not ready. Calculation aborted.");

  # This script checks if the motor is blocked and stops it in case of.
  - id: perform_motor_blocked_check
    mode: single
    then:
      - lambda: |-
          if (id(auto_motor_block_detection_on_off).state)
          {
            // check if elevation motor current is abnormal high and stop movement if needed

            if (id(elevation_motor_voltage_is_valid).state
                && id(elevation_motor_is_blocked_binary_sensor).state
                && ((esp_timer_get_time() / 1000) - id(panel_elevation_moving_start_date)) >= ${motor_high_current_check_delay})
            {
              // Motor blocked state detected(high current). Movement stopped & automatic controls deactivated.

              id(stop_panel_elevation_movement).execute();
              id(perform_deactivate_all_automatic_axis_controls).execute();  
              id(global_elevation_motor_blocked_high_current_fault_detected) = true;
              id(global_elevation_motor_blocked_high_current_timestamp) = id(ds3231_time).now().timestamp;
            }

            // check if azimuth motor current is abnormal high and stop movement if needed

            if (id(azimuth_motor_voltage_is_valid).state
                && id(azimuth_motor_is_blocked_binary_sensor).state
                && ((esp_timer_get_time() / 1000) - id(panel_azimuth_moving_start_date)) >= ${motor_high_current_check_delay})
            {
              // Motor blocked state detected(high current). Movement stopped & automatic controls deactivated. 

              id(stop_panel_rotation_movement).execute();    
              id(perform_deactivate_all_automatic_axis_controls).execute();
              id(global_azimuth_motor_blocked_high_current_fault_detected) = true;
              id(global_azimuth_motor_blocked_high_current_timestamp) = id(ds3231_time).now().timestamp;
            }

          }

  # this script checks if the motor current is (too) low in case the motor should actually move. This could indicate a motor connection problem.
  - id: perform_motor_connection_error_check
    mode: single
    then:
      - lambda: |-
          if (id(auto_motor_connection_error_detection_on_off).state)
          {
            // check if motor current is to low while motor should be active

            if (id(elevation_motor_voltage_is_valid).state
                and !id(elevation_axis_not_calibrated).state
                and !id(top_virtual_endstop_binary_sensor).state
                and !id(bottom_virtual_endstop_binary_sensor).state
                and (id(panel_lifting_planned).state or id(panel_lowering_planned).state)
                and id(elevation_motor_is_idle).state
                and ((esp_timer_get_time() / 1000) - id(panel_elevation_moving_start_date)) >= ${motor_connection_error_check_delay})
            { 
              // Motor connection error detected (low current). Elevation movement stopped & automatic controls deactivated. Check wiring!

              id(global_elevation_motor_not_connected_fault_detected) = true;
              id(global_elevation_motor_not_connected_timestamp) = id(ds3231_time).now().timestamp;
            }

            // check if motor current is to low while motor should be active

            if (id(azimuth_motor_voltage_is_valid).state
                and (id(panel_rotation_in_cw_planned).state or id(panel_rotation_in_ccw_planned).state)
                and id(azimuth_motor_is_idle).state
                //and id(elevation_motor_is_idle).state   // because elevation motor has higher priority we also check if elevation motor is idle to avoid false positives during elevation movements
                and ((esp_timer_get_time() / 1000.0) - id(panel_azimuth_moving_start_date)) >= ${motor_connection_error_check_delay})
            { 
              // Motor connection error detected (low current). Rotation movement stopped & automatic controls deactivated. Check wiring!

              id(global_azimuth_motor_not_connected_fault_detected) = true;
              id(global_azimuth_motor_not_connected_timestamp) = id(ds3231_time).now().timestamp;
            }
          }

  # This script checks if the current movement (measured by the IMU) fits to the active desired movement of the separate panel axis.
  - id: perform_panel_movement_plausible_check
    mode: single
    then:
      - lambda: |-
          // check if panel angle changed while motor is moving
          // This checks that the angle is changing in the same direction like the current linear actuator movement direction and stops the movement if not

          if (id(auto_motor_direction_detection_on_off).state)
          {
            // === DETECT WRONG ELEVATION MOTOR DIRECTION ===
            if (!id(global_elevation_motor_wrong_direction_detected))
            {
              float elevation_tolerance = ${elevation_motor_direction_detection_tolerance};
              
              if (id(panel_lifting_active).state and 
                  (id(panel_elevation_angle_sensor).state <= (id(global_elevation_motor_start_angle) - elevation_tolerance)))
              {
                // Motor is set to lift but angle is significantly decreasing (beyond tolerance) - WRONG DIRECTION!
                id(global_elevation_motor_wrong_direction_detected) = true;
                id(global_elevation_motor_wrong_direction_timestamp) = id(ds3231_time).now().timestamp;
                id(stop_panel_elevation_movement).execute();

                ESP_LOGE("Motor direction check:", "ELEVATION MOTOR WRONG DIRECTION: Lifting commanded but angle %.2f decreased beyond tolerance (start: %.2f, tolerance: ±%.1f°)", 
                          id(panel_elevation_angle_sensor).state, id(global_elevation_motor_start_angle), elevation_tolerance);

              } else if (id(panel_lowering_active).state and 
                          (id(panel_elevation_angle_sensor).state >= (id(global_elevation_motor_start_angle) + elevation_tolerance)))
              {
                // Motor is set to lower but angle is significantly increasing (beyond tolerance) - WRONG DIRECTION!
                id(global_elevation_motor_wrong_direction_detected) = true;
                id(global_elevation_motor_wrong_direction_timestamp) = id(ds3231_time).now().timestamp;
                id(stop_panel_elevation_movement).execute();

                ESP_LOGE("Motor direction check:", "ELEVATION MOTOR WRONG DIRECTION: Lowering commanded but angle %.2f increased beyond tolerance (start: %.2f, tolerance: ±%.1f°)", 
                          id(panel_elevation_angle_sensor).state, id(global_elevation_motor_start_angle), elevation_tolerance);
              }
            }
          }

          if (id(auto_panel_block_detection_by_angle_on_off).state)
          {
            if (((esp_timer_get_time() / 1000) - id(panel_elevation_moving_start_date)) >= ${panel_movement_plausible_check_delay})
            {
              id(panel_imu).update();
              id(panel_elevation_angle_sensor).update();  

              // ===== Check elevation axis =====

              float elevation_angle_change = id(panel_elevation_angle_sensor).state - id(panel_elevation_angle_sensor_old_state);

              if(id(panel_lifting_active).state and 
                  (elevation_angle_change < ${panel_block_detection_elevation_opening_angle_change_minimum}))
              {
                // Motor blocked state detected(angle up not changing). Movement stopped.
                
                id(stop_panel_elevation_movement).execute();
                id(auto_control_elevation_angle).turn_off();

                id(global_elevation_motor_blocked_missing_angle_change_while_lift_fault_detected) = true;
                id(global_elevation_motor_blocked_missing_angle_lift_timestamp) = id(ds3231_time).now().timestamp;

                ESP_LOGE("Panel movement plausible check:", "Panel elevation angle change is only %.2f. Movement is stopped", elevation_angle_change);

              } else if(id(panel_lowering_active).state and
                  (elevation_angle_change > ${panel_block_detection_elevation_closing_angle_change_minimum}))
              {
                // Motor blocked state detected(angle down not changing). Movement stopped.

                id(stop_panel_elevation_movement).execute();
                id(auto_control_elevation_angle).turn_off();

                id(global_elevation_motor_blocked_missing_angle_change_while_lowering_fault_detected) = true;
                id(global_elevation_motor_blocked_missing_angle_lower_timestamp) = id(ds3231_time).now().timestamp;

                ESP_LOGE("Panel movement plausible check:", "Panel elevation angle change is only %.2f. Movement is stopped", elevation_angle_change);
              }
              id(panel_elevation_angle_sensor_old_state) = id(panel_elevation_angle_sensor).state;
            }

            // ===== Check azimuth axis =====

            if (((esp_timer_get_time() / 1000) - id(panel_azimuth_moving_start_date)) >= ${panel_movement_plausible_check_delay})
            {
              id(panel_imu).update();
              id(panel_compass_heading).update();  

              float azimuth_angle_change = id(panel_compass_heading).state - id(panel_azimuth_angle_sensor_old_state);

              // === DETECT WRONG AZIMUTH MOTOR DIRECTION ===
              // Azimuth range: 10° to 350° (no wraparound)
              if (id(auto_motor_direction_detection_on_off).state && !id(global_azimuth_motor_wrong_direction_detected))
              {
                float azimuth_tolerance = ${azimuth_motor_direction_detection_tolerance};
                
                if (id(panel_rotation_in_cw_active).state)
                {
                  // For CW rotation, heading should increase (considering tolerance)
                  if (azimuth_angle_change < -azimuth_tolerance)
                  {
                    // Heading is decreasing significantly (beyond tolerance) - WRONG DIRECTION!
                    id(global_azimuth_motor_wrong_direction_detected) = true;
                    id(global_azimuth_motor_wrong_direction_timestamp) = id(ds3231_time).now().timestamp;
                    id(stop_panel_rotation_movement).execute();
                    ESP_LOGE("Motor direction check:", "AZIMUTH MOTOR WRONG DIRECTION: CW rotation commanded but heading decreased %.2f° (tolerance: ±%.1f°)", azimuth_angle_change, azimuth_tolerance);
                  }
                } 
                else if (id(panel_rotation_in_ccw_active).state)
                {
                  // For CCW rotation, heading should decrease (considering tolerance)
                  if (azimuth_angle_change > azimuth_tolerance)
                  {
                    // Heading is increasing significantly (beyond tolerance) - WRONG DIRECTION!
                    id(global_azimuth_motor_wrong_direction_detected) = true;
                    id(global_azimuth_motor_wrong_direction_timestamp) = id(ds3231_time).now().timestamp;
                    id(stop_panel_rotation_movement).execute();
                    ESP_LOGE("Motor direction check:", "AZIMUTH MOTOR WRONG DIRECTION: CCW rotation commanded but heading increased %.2f° (tolerance: ±%.1f°)", azimuth_angle_change, azimuth_tolerance);
                  }
                }
              }

              if(id(panel_rotation_in_cw_active).state and 
                  (azimuth_angle_change < ${panel_block_detection_azimuth_cw_angle_change_minimum}))
              {                
                id(stop_panel_rotation_movement).execute();
                id(auto_control_azimuth_angle).turn_off();
                id(global_azimuth_motor_blocked_missing_angle_cw_timestamp) = id(ds3231_time).now().timestamp;

                ESP_LOGE("Panel movement plausible check:", "Panel azimuth angle change is only %2.0f. Movement is stopped", azimuth_angle_change);

              } else if(id(panel_rotation_in_ccw_active).state and 
                  (azimuth_angle_change > ${panel_block_detection_azimuth_ccw_angle_change_minimum}))
              {
                id(stop_panel_rotation_movement).execute();
                id(auto_control_azimuth_angle).turn_off();

                id(global_azimuth_motor_blocked_missing_angle_change_ccw_fault_detected) = true;
                id(global_azimuth_motor_blocked_missing_angle_ccw_timestamp) = id(ds3231_time).now().timestamp;

                id(global_azimuth_motor_blocked_missing_angle_change_ccw_fault_detected) = true;

                ESP_LOGE("Panel movement plausible check:", "Panel azimuth angle change is only %2.0f. Movement is stopped", azimuth_angle_change);
              }
              id(panel_azimuth_angle_sensor_old_state) = id(panel_compass_heading).state;

            }
          }

  # this executes the needed steps to lift the panel
  - id: start_panel_lifting
    mode: single
    then:

      - script.execute: stop_panel_rotation_movement    # since parallel movement of both axis must not be possible

      # now check if motor voltage is valid      
      - if:
          condition:
            and:
              - binary_sensor.is_on: elevation_motor_voltage_is_valid
              #- lambda: 'return !id(panel_elevation_angle_is_increasing).state;'  # We need to check this to avoid the down-up-movement if this script is triggered regularly
          then:
            if:
              condition:
                lambda: 'return id(top_virtual_endstop_binary_sensor).state;'
              then:
                - lambda: ESP_LOGW("Panel lift control:", "Top Endstop is reached. Panel lifting not started.");
              else:
                if:
                  condition:
                    binary_sensor.is_on: panel_lifting_active
                  then:
                    - lambda: ESP_LOGW("Panel lift control:", "Panel lifting already running.");
                  else:
                    # First check if the movement in the opposite direction is currently running and if yes: Stop movement first to prevent high inrush current
                    - if:
                        condition:
                          binary_sensor.is_on: panel_lowering_active
                        then:
                          - script.execute: stop_panel_elevation_movement
                          - delay: 500ms
                    # Store current elevation angle to detect wrong motor direction
                    - lambda: |-
                        id(panel_imu).update();
                        id(panel_elevation_angle_sensor).update();
                        id(global_elevation_motor_start_angle) = id(panel_elevation_angle_sensor).state;
                        id(global_elevation_motor_wrong_direction_detected) = false;
                    - if:
                        condition:
                          switch.is_on: elevation_motor_direction_inverted
                        then:
                          - switch.turn_on: motor_elevation_minus_pin
                          - switch.turn_off: motor_elevation_plus_pin
                        else:  
                          - switch.turn_off: motor_elevation_minus_pin
                          - switch.turn_on: motor_elevation_plus_pin                    
                    - lambda: ESP_LOGI("Panel lift control:", "Panel lifting started.");
                    - lambda: |-
                        id(panel_elevation_moving_start_date) = (esp_timer_get_time() / 1000.0); // Convert microseconds to milliseconds
                        id(panel_elevation_target_reached_handled) = false;  // Reset helper variable for new movement session
                    #- lambda: "id(panel_elevation_angle_sensor_old_state) = id(panel_elevation_angle_sensor).state;" TODO
          else:
            - if:
                condition:
                  - binary_sensor.is_off: elevation_motor_voltage_is_valid
                then:
                  - lambda: |-
                      ESP_LOGE("Start panel lifting:", "Motor voltage is invalid. Panel lifting not started.");                  

  # this executes the needed steps to lower the panel
  - id: start_panel_lowering
    mode: single
    then:

      - script.execute: stop_panel_rotation_movement    # since parallel movement of both axis must not be possible

      # now check if motor voltage is valid 
      - if:
          condition:
            binary_sensor.is_on: elevation_motor_voltage_is_valid
          then: 
            if:
              condition:
                lambda: 'return id(bottom_virtual_endstop_binary_sensor).state;'
              then:
                - lambda: ESP_LOGW("Panel lift control:", "Bottom Endstop is reached. Panel lowering not started.");
              else:
                if:
                  condition:
                    binary_sensor.is_on: panel_lowering_active
                  then:
                    - lambda: ESP_LOGW("Panel lift control:", "Panel lowering already running.");
                  else:
                    # First check if the movement in the opposite direction is currently running and if yes: Stop movement first to prevent high inrush current
                    - if:
                        condition:
                          binary_sensor.is_on: panel_lifting_active
                        then:
                          - script.execute: stop_panel_elevation_movement
                          - delay: 500ms
                    - if:
                        condition:
                          switch.is_on: elevation_motor_direction_inverted
                        then:
                          - switch.turn_off: motor_elevation_minus_pin
                          - switch.turn_on: motor_elevation_plus_pin
                        else:  
                          - switch.turn_on: motor_elevation_minus_pin
                          - switch.turn_off: motor_elevation_plus_pin
                    - lambda: ESP_LOGI("Panel lift control:", "Panel lowering started.");
                    - lambda: |-
                        id(panel_elevation_moving_start_date) = (esp_timer_get_time() / 1000.0); // Convert microseconds to milliseconds
                        id(panel_elevation_target_reached_handled) = false;  // Reset helper variable for new movement session
                    - lambda: |-
                        id(panel_imu).update();
                        id(panel_elevation_angle_sensor).update();
                        id(global_elevation_motor_start_angle) = id(panel_elevation_angle_sensor).state;
                        id(global_elevation_motor_wrong_direction_detected) = false;
                    #- lambda: "id(panel_elevation_angle_sensor_old_state) = id(panel_elevation_angle_sensor).state;" TODO
          else:
            - if:
                condition:
                  - binary_sensor.is_off: elevation_motor_voltage_is_valid
                then:
                  - lambda: |-
                      ESP_LOGE("Start panel lowering:", "Motor voltage is invalid. Panel lowering not started.");

  # this executes the needed steps to stop panel up/down movement
  - id: stop_panel_elevation_movement
    mode: single
    then:
      - lambda: |-
          if (!id(panel_lifting_active).state and !id(panel_lowering_active).state)
          {
            ESP_LOGE("Panel lift control:", "Panel elevation movement stopped.");
          }
      - switch.turn_off: motor_elevation_plus_pin
      - switch.turn_off: motor_elevation_minus_pin
      - delay: 300ms # Increase this value if needed. This pause is done to give the motor some time to stop. Otherwise the motor inrush current could be increased when a next movement is started directly.
      
  # this executes the needed steps to rotate the panel in CCW direction
  - id: start_panel_rotation_counterclockwise
    mode: single
    then:

      - script.execute: stop_panel_elevation_movement    # since parallel movement of both axis must not be possible

      # now check if motor voltage is valid 
      - if:
          condition:
            binary_sensor.is_on: azimuth_motor_voltage_is_valid
          then: 
            if:
              condition:
                binary_sensor.is_off: azimuth_endstop_max_ccw_pos
              then:                
                if:
                  condition:
                    binary_sensor.is_on: panel_rotation_in_ccw_active
                  then:
                    - lambda: ESP_LOGI("Panel rotation control:", "Panel rotation in CCW direction already running.");
                  else:
                    # First check if the movement in the opposite direction is currently running and if yes: Stop movement first to prevent high inrush current
                    - if:
                        condition:
                          binary_sensor.is_on: panel_rotation_in_cw_active
                        then:
                          - script.execute: stop_panel_rotation_movement
                          - delay: 300ms
                    - if:
                        condition:
                          switch.is_on: azimuth_motor_direction_inverted
                        then:
                          - switch.turn_on: motor_azimuth_plus_pin
                          - switch.turn_off: motor_azimuth_minus_pin
                        else:  
                          - switch.turn_off: motor_azimuth_plus_pin
                          - switch.turn_on: motor_azimuth_minus_pin 
                    - lambda: ESP_LOGI("Panel rotation control:", "Panel rotation in CCW direction started.");

                    - lambda: |-
                        id(panel_azimuth_moving_start_date) = (esp_timer_get_time() / 1000.0); // Convert microseconds to milliseconds
                        id(panel_azimuth_target_reached_handled) = false;  // Reset helper variable for new movement session

                    - lambda: |-
                        id(panel_imu).update();
                        id(panel_compass_heading).update();
                        id(global_azimuth_motor_start_angle) = id(panel_compass_heading).state;
                        id(global_azimuth_motor_wrong_direction_detected) = false;
                    #- lambda: "id(panel_elevation_angle_sensor_old_state) = id(panel_elevation_angle_sensor).state;" TODO
              else:
                - lambda: ESP_LOGI("Panel rotation control:", "Panel rotation in CCW direction not started because endstop is reached.");


  # this executes the needed steps to rotate the panel in CW direction
  - id: start_panel_rotation_clockwise
    mode: single
    then:

      - script.execute: stop_panel_elevation_movement    # since parallel movement of both axis must not be possible

      # now check if motor voltage is valid 
      - if:
          condition:
            binary_sensor.is_on: azimuth_motor_voltage_is_valid
          then: 
            if:
              condition:
                binary_sensor.is_off: azimuth_endstop_max_cw_pos
              then:      
                if:
                  condition:
                    binary_sensor.is_on: panel_rotation_in_cw_active
                  then:
                    - lambda: ESP_LOGI("Panel rotation control:", "Panel rotation in CW direction already running.");
                  else:
                    # First check if the movement in the opposite direction is currently running and if yes: Stop movement first to prevent high inrush current
                    - if:
                        condition:
                          binary_sensor.is_on: panel_rotation_in_ccw_active
                        then:
                          - script.execute: stop_panel_rotation_movement
                          - delay: 300ms
                    - if:
                        condition:
                          switch.is_on: azimuth_motor_direction_inverted
                        then:
                          - switch.turn_off: motor_azimuth_plus_pin
                          - switch.turn_on: motor_azimuth_minus_pin
                        else:
                          - switch.turn_on: motor_azimuth_plus_pin
                          - switch.turn_off: motor_azimuth_minus_pin

                    - lambda: ESP_LOGI("Panel rotation control:", "Panel rotation in CW direction started.");
                    - lambda: |-
                        id(panel_azimuth_moving_start_date) = (esp_timer_get_time() / 1000.0); // Convert microseconds to milliseconds
                        id(panel_azimuth_target_reached_handled) = false;  // Reset helper variable for new movement session
                    - lambda: |-
                        id(panel_imu).update();
                        id(panel_compass_heading).update();
                        id(global_azimuth_motor_start_angle) = id(panel_compass_heading).state;
                        id(global_azimuth_motor_wrong_direction_detected) = false;
                    #- lambda: "id(panel_elevation_angle_sensor_old_state) = id(panel_elevation_angle_sensor).state;" TODO
              else:
                - lambda: ESP_LOGI("Panel rotation control:", "Panel rotation in CW direction not started because endstop is reached.");
          else:
            - text_sensor.template.publish:
                id: azimuth_motor_status_text
                state: "Motor voltage is invalid. Rotation in CW direction stopped."

  # this executes the needed steps to stop panel rotation movement
  - id: stop_panel_rotation_movement
    mode: single
    then:      
      - lambda: |-
          if (id(panel_rotation_in_cw_active).state or id(panel_rotation_in_ccw_active).state)
          {
            ESP_LOGE("Panel rotation control:", "Panel rotation stopped.");
          }
      - switch.turn_off: motor_azimuth_plus_pin
      - switch.turn_off: motor_azimuth_minus_pin
      - delay: 300ms # Increase this value if needed. This pause is done to give the motor some time to stop. Otherwise the motor inrush current could be increased when a next movement is started directly.

  - id: perform_internet_connection_test
    mode: single
    then:
      - lambda: |-
          id(global_internet_connection_test_success) = false;
      - http_request.get:
          url: !lambda 'return id(connection_test_url).state;'
          max_response_buffer_size: 1kB
          on_response:
            then:
              - logger.log:
                  format: "Response status: %d, Duration: %u ms, Content length: %d"
                  args:
                    - response->status_code
                    - response->duration_ms
                    - response->content_length
              - lambda: |-
                  id(global_internet_connection_test_success) = int(response->status_code) == 200;
                  if (id(global_internet_connection_test_success))
                  {
                    ESP_LOGI("Internet connection test:", "Internet connection is available.");
                  } 
                  else
                  {
                    ESP_LOGE("Internet connection test:", "Internet connection is not available."); 
                  }

  - id: perform_openweathermap_data_retrieval_if_owm_data_is_old
    mode: single
    then:
      - if: 
          condition:
            - lambda: 'return id(owm_data_is_old).state;' 
          then:     
            - script.execute: perform_openweathermap_data_retrieval

  - id: perform_openweathermap_data_retrieval
    mode: single
    then:
      if:
        condition:
            binary_sensor.is_on: owm_api_key_entered
        then:
          - script.execute: perform_internet_connection_test
          - script.wait: perform_internet_connection_test
          - if: 
              condition:
                - lambda: 'return id(global_internet_connection_test_success);'  # Only execute the rest if internet connection is available      
              then: 
                - lambda: ESP_LOGI("OWM retrieval:", "Internet connection is available. Starting OWM data retrieval.");             
                - http_request.get:
                    url: !lambda 'return "http://api.openweathermap.org/data/3.0/onecall?lat=" + to_string(id(device_latitude).state) + "&lon=" + to_string(id(device_longitude).state) + "&exclude=minutely,daily,alerts&units=metric&appid=" + id(owm_api_key).state;'
                    request_headers:
                      Content-Type: application/json
                    capture_response: true
                    max_response_buffer_size: 20kB          
                    on_response:
                      then:
                        - logger.log:
                            format: "Response status: %d, Duration: %u ms, Content length: %d"
                            args:
                              - response->status_code
                              - response->duration_ms
                              - response->content_length
                        - logger.log:
                            format: "Response body: %s"
                            args:
                              - body.c_str()
                        - lambda: |-
                            id(global_owm_api_key_valid) = int(response->status_code) == 200;

                            if (id(global_owm_api_key_valid))
                            {
                              json::parse_json(body, [](JsonObject root) -> bool
                                {
                                    id(global_owm_wind_speed_current) = float(root["current"]["wind_speed"]);
                                    id(global_owm_wind_gusts_current) = float(root["current"]["wind_gust"]);
                                    id(global_owm_cloud_coverage_current) = float(root["current"]["clouds"]);
                                    id(global_owm_wind_speed_in_one_hour) = float(root["hourly"][0]["wind_speed"]);
                                    id(global_owm_wind_gusts_in_one_hour) = float(root["hourly"][0]["wind_gust"]);
                                    id(global_owm_cloud_coverage_in_one_hour) = float(root["hourly"][0]["clouds"]) ;
                                    
                                    // save time of last successfull data retrieval
                                    id(global_owm_last_data_retrieval_success) = id(ds3231_time).now().timestamp;
                                    id(last_owm_retrieval_success).update();
                                    ESP_LOGI("OWM retrieval:", "OWM data retrieval finished.");

                                    return true;
                                }
                              );
                            } else
                            {
                              ESP_LOGE("OWM retrieval:", "OWM API Key is not valid.");
                            }
              else:
                - lambda: ESP_LOGE("OWM retrieval:", "Internet connection is not available.");  
        else:
          - lambda: ESP_LOGE("OWM retrieval:", "API key is not entered.");  


display:
  #- platform: ssd1306_i2c
  #  model: "SSD1306 128x64"
  #  id: display1
  #  address: ${i2c_address.ssd1306}
  #  update_interval: 1s
  #  lambda: |-
  #        if (id(display_on_off).state) 
  #        {
  #          ${screensaver_offset} = ${screensaver_offset} < 10 ? ${screensaver_offset} + 2 : 0;
#
 #           it.print(0+${screensaver_offset}, 0+${screensaver_offset}, id(font3), "Sun-El:");
  #          it.print(0+${screensaver_offset}, 12+${screensaver_offset}, id(font3), "Sun-Az:");
   #         it.print(0+${screensaver_offset}, 24+${screensaver_offset}, id(font3), "Pan-Ez:");
    #        it.print(0+${screensaver_offset}, 36+${screensaver_offset}, id(font3), "Pan-Az:");
     #       it.print(0+${screensaver_offset}, 48+${screensaver_offset}, id(font3), "Time:");
      #    } else 
       #   {
        #    it.fill(COLOR_OFF);
         # }


font:
  - file: 'fonts/calibri.ttf'
    id: font1
    size: 24
  - file: 'fonts/calibri.ttf'
    id: font2
    size: 14
  - file: 'fonts/calibri.ttf'
    id: font3
    size: 10
    
light:
  - platform: binary
    id: mcu_led
    output: mcu_led_output_id
    internal: true

  - platform: esp32_rmt_led_strip
    restore_mode: ALWAYS_OFF
    id: status_led_string
    rgb_order: GRB
    chipset: WS2812
    pin: ${gpio.led_out}
    num_leds: 4
    internal: true  

  - platform: partition
    name: "Motor Status"
    id: motor_status_led
    default_transition_length: 1s
    internal: true
    segments:
      - id: status_led_string
        from: 0
        to: 0
    effects:
      - pulse:
          name: "Fast Pulse"
          transition_length: 0.5s
          update_interval: 0.5s
          min_brightness: 0%
          max_brightness: 100%
      - pulse:
          name: "Slow Pulse"
          transition_length: 500ms
          update_interval: 2s
      - pulse:
          name: "Asymmetrical Pulse"
          transition_length:
            on_length: 1s
            off_length: 500ms
          update_interval: 1.5s

  - platform: partition
    name: "Wifi Status"
    id: wifi_status_led
    default_transition_length: 1s
    internal: true
    segments:
      - id: status_led_string
        from: 1
        to: 1
    effects:
      - pulse:
          name: "Fast Pulse"
          transition_length: 0.5s
          update_interval: 0.5s
          min_brightness: 0%
          max_brightness: 100%
      - pulse:
          name: "Slow Pulse"
          transition_length: 500ms
          update_interval: 2s
      - pulse:
          name: "Asymmetrical Pulse"
          transition_length:
            on_length: 1s
            off_length: 500ms
          update_interval: 1.5s

  - platform: partition
    name: "Sensor Status"
    id: sensor_status_led
    default_transition_length: 1s
    internal: true
    segments:
      - id: status_led_string
        from: 2
        to: 2
    effects:
      - pulse:
          name: "Fast Pulse"
          transition_length: 0.5s
          update_interval: 0.5s
          min_brightness: 0%
          max_brightness: 100%
      - pulse:
          name: "Slow Pulse"
          transition_length: 500ms
          update_interval: 2s
      - pulse:
          name: "Asymmetrical Pulse"
          transition_length:
            on_length: 1s
            off_length: 500ms
          update_interval: 1.5s

  - platform: partition
    name: "Main Status Extern"
    id: main_status_extern_led
    default_transition_length: 1s
    internal: true
    segments:
      - id: status_led_string
        from: 3
        to: 3
    effects:
      - pulse:
          name: "Fast Pulse"
          transition_length: 0.5s
          update_interval: 0.5s
          min_brightness: 0%
          max_brightness: 100%
      - pulse:
          name: "Slow Pulse"
          transition_length: 500ms
          update_interval: 2s
      - pulse:
          name: "Asymmetrical Pulse"
          transition_length:
            on_length: 1s
            off_length: 500ms
          update_interval: 1.5s